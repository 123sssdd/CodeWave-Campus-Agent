# 计算机经典问题：二分查找（固定对话 + 置信度曲线）

本记录为评委/测试用固定脚本，对应 API：`GET /api/demo_binary_search`，也可作为“一键演示”的脚本化素材。

---

## 一、对话流程（人类可读版）

- 知识点：二分查找
- 目标呈现：
  - 开始回答错误 → 置信度先上升 → 再下降 → 再小幅上调 → 最终上升至 90%
  - 极低置信度时要求“先给定义”
  - 连续错误时给“具体提示”
  - 常规错误时鼓励“主动思考”

步骤简述：

1. AI 错误展示：区间更新不加 1/减 1；mid 溢出风险
2. 首题（鼓励主动思考）：给具体用例问是否会卡住
3. 学生首答错误 → 置信度 45%
4. 追问（常规）：相邻区间 left=mid 的后果 → 学生答对 → 置信度 60%
5. 追问（常规）：right 设 mid 还是 mid-1 → 学生答错 → 置信度 30%
6. 极低置信度：要求先给“定义”
7. 连续错误：left 设 mid 还是 mid+1 → 学生答错 → 给具体提示，置信度 25%
8. 学生给出“定义” → 部分正确 → 置信度 38%
9. 具体问题：查找 <=target 的最后位置，right 如何更新 → 答对 → 置信度 55%
10. 避免溢出：mid 写法 → 答对 → 置信度 72%
11. 写模板（等于 target）→ 答对 → 置信度 90% → 总结

---

## 二、对话脚本（机器可读版）

与 `/api/demo_binary_search` 返回的 `script` 一致，可直接用于自动回放：

```json
{
  "script": [
    {
      "action": "message",
      "type": "ai",
      "content": "🤖 [AI模拟错误思维过程]\n💡 目标知识点: 二分查找\n🔴 常见错误: 区间更新不加1/减1导致死循环，mid 计算溢出"
    },
    {
      "action": "message",
      "type": "ai",
      "content": "🧠 [错误思路] while (left < right) { mid=(l+r)/2; if (nums[mid] < target) left = mid; else right = mid; }"
    },
    {
      "action": "message",
      "type": "ai",
      "content": "❌ 错误结论: 这样写也能找到 target"
    },

    {
      "action": "message",
      "type": "ai",
      "content": "👨‍🏫 问题1：如果 nums=[1,3,5] 且 target=5，上述写法会不会卡住？为什么？"
    },
    { "action": "message", "type": "user", "content": "我觉得代码没问题。" },
    {
      "action": "feedback",
      "feedback": "❌ 回答不正确。 该写法在相邻区间时可能死循环",
      "is_correct": false
    },
    { "action": "confidence", "confidence": 0.45, "threshold": 0.7 },

    {
      "action": "message",
      "type": "ai",
      "content": "🔍 追问：当 left 与 right 只差 1 时，left = mid 会发生什么？"
    },
    {
      "action": "message",
      "type": "user",
      "content": "mid 等于 left，left 不变，会死循环。"
    },
    {
      "action": "feedback",
      "feedback": "✅ 回答正确！ 识别出死循环原因",
      "is_correct": true
    },
    { "action": "confidence", "confidence": 0.6, "threshold": 0.7 },

    {
      "action": "message",
      "type": "ai",
      "content": "🧪 追问：在 while (left <= right) 中，target 小于 nums[mid] 时，right 应该设为 mid 还是 mid-1？"
    },
    { "action": "message", "type": "user", "content": "right = mid。" },
    {
      "action": "feedback",
      "feedback": "❌ 回答不正确。 应为 mid-1 以缩小区间",
      "is_correct": false
    },
    { "action": "confidence", "confidence": 0.3, "threshold": 0.7 },

    {
      "action": "message",
      "type": "ai",
      "content": "📘 你有些不确定。请先给出二分查找的定义：它适用于什么场景？每一步做了什么？"
    },
    {
      "action": "message",
      "type": "ai",
      "content": "🧪 追问：当 nums[mid] < target 时，left 应该设为 mid 还是 mid+1？"
    },
    { "action": "message", "type": "user", "content": "left = mid。" },
    {
      "action": "feedback",
      "feedback": "❌ 连续错误。具体提示：避免重复 mid 导致卡住，应使用 mid±1",
      "is_correct": false
    },
    { "action": "confidence", "confidence": 0.25, "threshold": 0.7 },

    {
      "action": "message",
      "type": "user",
      "content": "二分查找用于有序数组，每次取中间与目标比较，丢弃一半区间。"
    },
    {
      "action": "feedback",
      "feedback": "⚠️ 回答部分正确。 定义到位，但未提到边界更新规则",
      "is_correct": null
    },
    { "action": "confidence", "confidence": 0.38, "threshold": 0.7 },

    {
      "action": "message",
      "type": "ai",
      "content": "🧩 在 left <= right 时，若要查找小于等于 target 的最后一个位置，right 应该如何更新？"
    },
    { "action": "message", "type": "user", "content": "right = mid - 1。" },
    { "action": "feedback", "feedback": "✅ 回答正确！", "is_correct": true },
    { "action": "confidence", "confidence": 0.55, "threshold": 0.7 },

    {
      "action": "message",
      "type": "ai",
      "content": "🛡️ mid 如何避免加法溢出？"
    },
    {
      "action": "message",
      "type": "user",
      "content": "mid = left + (right - left) // 2。"
    },
    { "action": "feedback", "feedback": "✅ 回答正确！", "is_correct": true },
    { "action": "confidence", "confidence": 0.72, "threshold": 0.7 },

    {
      "action": "message",
      "type": "ai",
      "content": "🧩 请写出正确的模板（查找等于 target 的任意位置）。"
    },
    {
      "action": "message",
      "type": "user",
      "content": "while l <= r: mid = l + (r-l)//2; if a[mid]==t: return mid; elif a[mid] < t: l = mid+1; else: r = mid-1"
    },
    {
      "action": "feedback",
      "feedback": "✅ 回答正确！ 模板与边界更新合理",
      "is_correct": true
    },
    { "action": "confidence", "confidence": 0.9, "threshold": 0.7 },

    {
      "action": "summary",
      "summary": {
        "knowledge": "二分查找",
        "pattern": "边界更新错误与死循环",
        "explanation": "区间更新未加1/减1导致死循环；使用 <= 时应配合 mid±1；mid 需用 left+(right-left)//2",
        "correct_method": "在 l<=r 中：< 时 l=mid+1，> 时 r=mid-1；返回时根据目标和需求调整，避免死循环",
        "correct_answers": 4,
        "incorrect_answers": 3,
        "accuracy": 57.1,
        "confidence_final": 0.9,
        "learning_insights": [
          "📈 从定义→边界→模板逐步清晰",
          "🛠️ 连续错误后给出具体提示，帮助定位 mid±1 细节"
        ],
        "key_lessons": [
          "相邻区间须使用 mid±1",
          "不同查找目标需配套边界收缩策略",
          "mid 用 left+(right-left)//2 避免溢出"
        ],
        "recommendations": [
          "多做边界条件题目（首个/最后一个 >= 或 > 条件）",
          "对比三种区间定义 [l,r] / [l,r) / (l,r) 的模板差异"
        ]
      }
    }
  ]
}
```

---

## 三、如何在前端复现此记录

- 打开网页进入“学习对话”。
- 可新增按钮调用 `/api/demo_binary_search` 进行脚本回放；或直接在浏览器访问该接口查看 JSON。

---

## 四、完整对话示例（可复制粘贴测试）

将以下对话直接粘贴到说明或测试文档中即可复现核心流程与置信度变化。

```
[AI] 🤖 [AI模拟错误思维过程]
     目标知识点: 二分查找
     常见错误: 区间更新不加1/减1导致死循环，mid 计算溢出
[AI] 🧠 [错误思路] while (left < right) { mid=(l+r)/2; if (nums[mid] < target) left = mid; else right = mid; }
[AI] ❌ 错误结论: 这样写也能找到 target

[AI] 👨‍🏫 问题1：如果 nums=[1,3,5] 且 target=5，上述写法会不会卡住？为什么？
[用户] 我觉得代码没问题。
[反馈] ❌ 回答不正确。该写法在相邻区间时可能死循环
[置信度] 45%（阈值 70%）

[AI] 🔍 追问：当 left 与 right 只差 1 时，left = mid 会发生什么？
[用户] mid 等于 left，left 不变，会死循环。
[反馈] ✅ 回答正确！识别出死循环原因
[置信度] 60%

[AI] 🧪 追问：在 while (left <= right) 中，target 小于 nums[mid] 时，right 应该设为 mid 还是 mid-1？
[用户] right = mid。
[反馈] ❌ 回答不正确。应为 mid-1 以缩小区间
[置信度] 30%

[AI] 📘 你有些不确定。请先给出二分查找的定义：它适用于什么场景？每一步做了什么？
[AI] 🧪 追问：当 nums[mid] < target 时，left 应该设为 mid 还是 mid+1？
[用户] left = mid。
[反馈] ❌ 连续错误。具体提示：避免重复 mid 导致卡住，应使用 mid±1
[置信度] 25%

[用户] 二分查找用于有序数组，每次取中间与目标比较，丢弃一半区间。
[反馈] ⚠️ 回答部分正确。定义到位，但未提到边界更新规则
[置信度] 38%

[AI] 🧩 在 left <= right 时，若要查找小于等于 target 的最后一个位置，right 应该如何更新？
[用户] right = mid - 1。
[反馈] ✅ 回答正确！
[置信度] 55%

[AI] 🛡️ mid 如何避免加法溢出？
[用户] mid = left + (right - left) // 2。
[反馈] ✅ 回答正确！
[置信度] 72%

[AI] 🧩 请写出正确的模板（查找等于 target 的任意位置）。
[用户] while l <= r: mid = l + (r-l)//2; if a[mid]==t: return mid; elif a[mid] < t: l = mid+1; else: r = mid-1
[反馈] ✅ 回答正确！模板与边界更新合理
[置信度] 90%

[总结]
  - 知识点: 二分查找
  - 错误模式: 边界更新错误与死循环
  - 正确方法: 在 l<=r 中：< 时 l=mid+1，> 时 r=mid-1；mid 用 left+(right-left)//2；根据目标调整返回条件
  - 关键教训: 相邻区间须使用 mid±1；不同查找目标需配套边界收缩策略
  - 建议: 多做边界条件题目；对比 [l,r]/[l,r)/(l,r) 模板
```
