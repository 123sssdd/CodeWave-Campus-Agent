{
  "knowledge_points": [
    {
      "name": "Vue 3 组合式 API (Composition API) 与响应式原理",
      "category": "Vue",
      "description": "深入理解 `ref`、`reactive` 的实现机制，`effect` 的依赖收集与触发更新过程，以及如何利用组合式 API 组织复杂的业务逻辑。",
      "difficulty_level": 4
    },
    {
      "name": "React Concurrent Mode 与 Fiber 架构",
      "category": "React",
      "description": "理解 Fiber 架构如何实现可中断、可恢复的渲染，以及 Concurrent Mode（并发模式）下的新特性，如 `useTransition` 和 `useDeferredValue` 如何优化用户体验。",
      "difficulty_level": 5
    },
    {
      "name": "JavaScript 事件循环 (Event Loop) 与微任务/宏任务",
      "category": "JS",
      "description": "彻底搞懂浏览器和 Node.js 环境下 Event Loop 的不同之处，精确掌握 `Promise.then`, `async/await`, `setTimeout`, `setImmediate` 等的执行顺序。",
      "difficulty_level": 4
    },
    {
      "name": "Golang Goroutine 调度器 (G-P-M 模型)",
      "category": "Golang",
      "description": "深入理解 Goroutine、Processor 和 Machine（内核线程）之间的协作关系，以及 Go 调度器如何实现高效的并发调度和抢占。",
      "difficulty_level": 5
    },
    {
      "name": "Webpack/Vite 性能优化与插件开发",
      "category": "前端工程化",
      "description": "掌握 Tree Shaking、Code Splitting、持久化缓存等高级优化策略，并具备编写自定义 Loader 和 Plugin 以解决复杂工程问题的能力。",
      "difficulty_level": 4
    },
    {
      "name": "Golang 内存管理与垃圾回收 (GC)",
      "category": "Golang",
      "description": "了解 Go 的内存分配机制（如 `tcmalloc`），以及三色标记法在并发垃圾回收中的应用，并学会使用 pprof 等工具进行内存泄漏分析。",
      "difficulty_level": 4
    },
    {
      "name": "React Server Components (RSC)",
      "category": "React",
      "description": "理解 RSC 的工作原理，它与客户端组件 (Client Components) 的区别，以及如何利用它来优化初始加载性能和减少客户端包体积。",
      "difficulty_level": 4
    },
    {
      "name": "JS V8 引擎工作原理",
      "category": "JS",
      "description": "了解 V8 引擎如何解析、编译和执行 JavaScript 代码，包括 JIT (Just-In-Time) 编译器、内存堆栈、垃圾回收机制和性能优化策略。",
      "difficulty_level": 5
    },
    {
      "name": "Vue 服务端渲染 (SSR) 与同构应用",
      "category": "Vue",
      "description": "掌握 Nuxt.js 或原生 Vue SSR 的实现方案，理解其生命周期、数据预取、状态水合 (Hydration) 等核心概念，并解决 SEO 和首屏加载问题。",
      "difficulty_level": 4
    },
    {
      "name": "Golang Channel 的高级用法与并发模式",
      "category": "Golang",
      "description": "熟练运用 `select` 处理多通道读写，掌握超时、扇入、扇出、Pipeline 等经典并发模式，并理解非缓冲和缓冲 Channel 的底层实现差异。",
      "difficulty_level": 4
    }
  ],
  "theory_questions": [
    {
      "title": "Vue 3 组合式 API",
      "content": "请解释 Vue 3 的组合式 API (Composition API) 相比于选项式 API (Options API) 的主要优势是什么？并说明 `ref` 和 `reactive` 的核心区别。",
      "question_type": "theory",
      "difficulty": "medium",
      "estimated_time": 15,
      "knowledge_point_id": 1,
      "correct_answer": "主要优势在于更好地组织和重用逻辑，尤其是在大型复杂组件中。`ref` 用于将基本数据类型包装成响应式对象，通过 `.value` 访问；`reactive` 用于将复杂数据类型（对象、数组）转换成响应式代理，直接访问属性。",
      "explanation": "组合式 API 解决了选项式 API 在逻辑分散和 Mixin 命名冲突等方面的痛点，是 Vue 3 的核心特性之一。"
    },
    {
      "title": "React Fiber 架构",
      "content": "React 的 Fiber 架构是什么？它解决了什么核心问题，并如何实现可中断和恢复的渲染？",
      "question_type": "theory",
      "difficulty": "hard",
      "estimated_time": 20,
      "knowledge_point_id": 2,
      "correct_answer": "Fiber 是对 React 核心算法的重写。它解决了旧版架构中更新过程同步且不可中断的问题，可能导致长时间任务阻塞主线程。它通过将渲染/更新工作分割成多个小单元（Fiber节点），并利用 `requestIdleCallback` 在浏览器的空闲时段执行这些单元，从而实现了任务的可中断、恢复和优先级调度。",
      "explanation": "Fiber 架构是 React 并发模式 (Concurrent Mode) 的基础，极大地提升了复杂应用的响应性和用户体验。"
    },
    {
      "title": "JavaScript 事件循环",
      "content": "请详细描述浏览器环境下的事件循环 (Event Loop) 机制，并解释宏任务 (Macrotask) 和微任务 (Microtask) 的区别以及它们的执行顺序。",
      "question_type": "theory",
      "difficulty": "hard",
      "estimated_time": 20,
      "knowledge_point_id": 3,
      "correct_answer": "事件循环是一个持续处理任务队列的机制。执行栈执行完同步代码后，会检查微任务队列，执行并清空所有微任务。然后，取出一个宏任务来执行。执行完该宏任务后，再次检查并清空微任务队列。如此循环往复。宏任务包括 `setTimeout`、`setInterval`、I/O 等；微任务包括 `Promise.then`、`async/await`、`MutationObserver`。",
      "explanation": "理解宏任务和微任务的执行时机是掌握 JavaScript 异步编程的关键，也是面试中的高频考点。"
    },
    {
      "title": "Golang G-P-M 模型",
      "content": "请解释 Golang 的 Goroutine 调度器中的 G-P-M 模型分别代表什么，以及它们之间是如何协作来高效实现并发的？",
      "question_type": "theory",
      "difficulty": "hard",
      "estimated_time": 25,
      "knowledge_point_id": 4,
      "correct_answer": "G 代表 Goroutine（协程），是 Go 的并发执行单元。P 代表 Processor（处理器），是 G 运行所需要的上下文环境。M 代表 Machine（内核线程），是真正执行代码的实体。调度器将 G 分配到 P 的本地队列中，然后 P 会与一个 M 绑定来执行 G。这种模型通过 P 的本地队列减少了锁竞争，并支持工作窃取（work-stealing）来平衡负载，实现了用户态的高效并发调度。",
      "explanation": "G-P-M 模型是 Golang 高并发性能的核心，它将用户态的 Goroutine 与内核线程解耦，实现了轻量级且高效的并发。"
    },
    {
      "title": "Tree Shaking 原理",
      "content": "在前端工程化中，什么是 Tree Shaking？它的工作原理是什么，以及实现它需要满足哪些条件？",
      "question_type": "theory",
      "difficulty": "medium",
      "estimated_time": 15,
      "knowledge_point_id": 5,
      "correct_answer": "Tree Shaking 是一种通过移除 JavaScript 上下文中未引用的代码来优化打包体积的技术。其工作原理是利用 ES6 模块（ESM）的静态导入导出语法，在编译时进行静态分析，确定哪些代码是“活”的（被引用），哪些是“死”的（未被引用），然后在最终打包时剔除“死”代码。实现条件是必须使用 ES6 模块语法。",
      "explanation": "Tree Shaking 对于减少现代前端应用的最终包大小至关重要，是 Webpack 和 Vite 等构建工具的核心优化功能之一。"
    },
    {
      "title": "Golang 垃圾回收",
      "content": "简述 Golang 的垃圾回收（GC）机制，特别是三色标记法的工作流程。",
      "question_type": "theory",
      "difficulty": "hard",
      "estimated_time": 20,
      "knowledge_point_id": 6,
      "correct_answer": "Golang 使用并发的三色标记-清除法。对象被分为白、灰、黑三组。初始时所有对象为白色。GC从根对象开始，将其标记为灰色。然后遍历灰色对象，将其引用的白色对象标记为灰色，并将自身标记为黑色。此过程持续直到没有灰色对象。最后，所有剩余的白色对象即为垃圾，将被回收。通过写屏障（Write Barrier）技术来保证在 GC 扫描过程中，业务逻辑（mutator）并发修改对象引用不会破坏 GC 的正确性。",
      "explanation": "Go 的并发 GC 机制通过 STW（Stop-The-World）时间极短的特点，保证了应用的高吞吐量和低延迟。"
    },
    {
      "title": "React Server Components",
      "content": "React Server Components (RSC) 和传统的服务端渲染 (SSR) 有什么本质区别？RSC 带来了哪些好处？",
      "question_type": "theory",
      "difficulty": "hard",
      "estimated_time": 15,
      "knowledge_point_id": 7,
      "correct_answer": "本质区别在于 SSR 是在服务器上将整个 React 组件树渲染成 HTML 字符串返回给客户端，客户端需要“水合”（hydrate）来附加事件监听器。而 RSC 是在服务器上执行并返回一种中间抽象格式（类 JSON），它不产生 HTML，可以在不增加客户端 JS 体积的情况下，与客户端组件（Client Components）混合渲染。好处包括：零客户端包体积、可直接访问后端资源、自动代码分割。",
      "explanation": "RSC 是 React 对前后端架构的全新探索，旨在结合服务端渲染和客户端渲染的优点。"
    },
    {
      "title": "JS V8 引擎工作流程",
      "content": "请简要描述 Google V8 引擎是如何执行 JavaScript 代码的，提及 JIT（即时编译）在其中的作用。",
      "question_type": "theory",
      "difficulty": "hard",
      "estimated_time": 20,
      "knowledge_point_id": 8,
      "correct_answer": "V8 引擎首先通过解析器（Parser）将 JS 代码转换成抽象语法树（AST）。然后，解释器（Ignition）会将 AST 转换成字节码并执行。在执行过程中，JIT 编译器（TurboFan）会监控热点代码（被频繁执行的代码），将其编译成高度优化的本地机器码，以提升执行速度。如果优化的假设失败，会进行去优化，退回到字节码执行。",
      "explanation": "V8 引擎通过解释执行和即时编译相结合的方式，在执行速度和启动时间之间取得了很好的平衡。"
    },
    {
      "title": "Vue 服务端渲染 (SSR) 的水合",
      "content": "在 Vue SSR 的语境下，“水合” (Hydration) 指的是什么过程？为什么这个过程是必需的？",
      "question_type": "theory",
      "difficulty": "medium",
      "estimated_time": 15,
      "knowledge_point_id": 9,
      "correct_answer": "水合是指客户端 Vue 接管由服务器发送过来的静态 HTML 的过程。服务器端渲染只生成了页面的 HTML 结构，但缺少交互性。当客户端的 JS 加载并执行后，Vue 会遍历服务端渲染的 DOM 树，将事件监听器和响应式数据附加到现有的 DOM 元素上，使其“活”过来，变得可交互。这个过程就是水合。它是必需的，因为它将静态页面转换为了功能完整的单页应用 (SPA)。",
      "explanation": "理解水合是掌握 SSR 的关键，水合失败（mismatch）是 SSR 应用中常见的调试难点。"
    },
    {
      "title": "Golang Channel 的应用场景",
      "content": "除了基本的 Goroutine 间通信，请列举并简要说明 Golang 中 Channel 的至少三种高级应用模式。",
      "question_type": "theory",
      "difficulty": "medium",
      "estimated_time": 15,
      "knowledge_point_id": 10,
      "correct_answer": "1. **并发控制**：使用带缓冲的 Channel 来控制并发任务的数量，例如 `ch := make(chan struct{}, 10)`，每次启动 Goroutine 前向 channel 发送一个值，任务结束后再接收一个值，从而保证最多只有 10 个任务在并发执行。 2. **超时控制**：利用 `select` 和 `time.After` 来实现对某个操作的超时处理。 3. **任务编排/同步**：使用无缓冲的 Channel 作为信号量，等待一个或多个 Goroutine 完成任务，类似 `sync.WaitGroup` 的功能。",
      "explanation": "Channel 是 Go 并发编程的核心构件，熟练掌握其高级模式是编写健壮、高效并发程序的关键。"
    }
  ],
  "multiple_choice_questions": [
    {
      "title": "React Hooks 规则",
      "content": "下列关于 React Hooks 的使用规则，哪一项是错误的？",
      "question_type": "multiple_choice",
      "difficulty": "medium",
      "estimated_time": 5,
      "knowledge_point_id": 2,
      "options": "[\"A. 只能在函数组件的顶层调用 Hooks\",\"B. 可以在 JavaScript 普通函数中调用 Hooks\",\"C. 只能在 React 函数组件或自定义 Hook 中调用 Hooks\",\"D. 不可以在循环、条件或嵌套函数中调用 Hooks\"]",
      "correct_answer": "B",
      "explanation": "React Hooks 依赖于调用顺序来正确地关联状态和组件实例，因此它们不能在普通的 JavaScript 函数中调用，必须在 React 函数组件或自定义 Hook 的顶层调用。"
    },
    {
      "title": "Vue 指令 v-if 与 v-show",
      "content": "关于 Vue 的 `v-if` 和 `v-show` 指令，以下描述哪个是正确的？",
      "question_type": "multiple_choice",
      "difficulty": "medium",
      "estimated_time": 5,
      "knowledge_point_id": 1,
      "options": "[\"A. `v-if` 的切换开销比 `v-show` 更高\",\"B. `v-show` 是懒加载的，初始条件为 false 时什么都不渲染\",\"C. 频繁切换显示/隐藏状态的场景，推荐使用 `v-if`\",\"D. `v-if` 控制的 DOM 元素会始终保留在 DOM 树中\"]",
      "correct_answer": "A",
      "explanation": "`v-if` 是“真正的”条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件被适当地销毁和重建，因此有更高的切换开销。而`v-show` 只是简单地切换元素的 CSS `display` 属性，初始渲染开销更高，但切换开销小。"
    },
    {
      "title": "Golang defer 语句",
      "content": "在 Golang 中，以下关于 `defer` 语句的描述，哪一个是错误的？",
      "question_type": "multiple_choice",
      "difficulty": "medium",
      "estimated_time": 8,
      "knowledge_point_id": 10,
      "options": "[\"A. `defer` 语句会在函数返回前执行\",\"B. 多个 `defer` 语句遵循“后进先出”（LIFO）的执行顺序\",\"C. `defer` 后的函数参数在 `defer` 语句执行时才被计算\",\"D. `defer` 常用于资源释放，如关闭文件和解锁\"]",
      "correct_answer": "C",
      "explanation": "`defer` 语句后面的函数参数是在 `defer` 语句被定义时就立即求值的，而不是等到函数返回前才求值。这是 `defer` 的一个重要特性，也是常见的“陷阱”。"
    },
    {
      "title": "JavaScript 严格相等",
      "content": "在 JavaScript 中，表达式 `[] == ![]` 的结果是什么？",
      "question_type": "multiple_choice",
      "difficulty": "hard",
      "estimated_time": 8,
      "knowledge_point_id": 3,
      "options": "[\"A. true\",\"B. false\",\"C. TypeError\",\"D. SyntaxError\"]",
      "correct_answer": "A",
      "explanation": "这是一个经典的 JS 类型转换问题。`![]` 首先被计算，数组 `[]` 是一个“真值”对象，所以 `![]` 的结果是 `false`。表达式变为 `[] == false`。根据相等（==）运算符的规则，当对象与布尔值比较时，对象会转换为原始值（`[]` 转换为 `''`），布尔值会转换为数字（`false` 转换为 `0`）。表达式变为 `'' == 0`。字符串 `''` 转换为数字 `0`，最终 `0 == 0`，结果为 `true`。"
    },
    {
      "title": "Golang select 语句",
      "content": "在 Golang 的 `select` 语句中，当有多个 case 同时准备就绪时，会发生什么？",
      "question_type": "multiple_choice",
      "difficulty": "medium",
      "estimated_time": 5,
      "knowledge_point_id": 10,
      "options": "[\"A. 按照代码中 case 的书写顺序执行第一个就绪的\",\"B. 随机选择一个就绪的 case 来执行\",\"C. 所有就绪的 case 都会被执行\",\"D. 会产生一个 panic\"]",
      "correct_answer": "B",
      "explanation": "Go 语言规范明确指出，如果 `select` 语句中有多个 case 可以执行，则会进行伪随机选择一个来执行。这样做是为了防止饥饿，确保每个通道都有机会被处理。"
    }
  ],
  "coding_problems": [
    {
      "title": "实现 Debounce 函数",
      "content": "请用 JavaScript 实现一个 debounce (防抖) 函数。该函数接收一个函数 func 和一个延迟时间 wait，并返回一个新函数。当返回的新函数被连续调用时，它只会在最后一次调用后的 wait 毫秒后执行 func。",
      "question_type": "coding",
      "difficulty": "medium",
      "estimated_time": 30,
      "knowledge_point_id": 3,
      "programming_language": "javascript",
      "starter_code": "function debounce(func, wait) {\n  let timeout;\n\n  return function(...args) {\n    const context = this;\n    // 在这里实现你的核心逻辑\n  }\n}",
      "correct_answer": "使用闭包保存一个定时器ID。每次函数被调用时，清除上一个定时器，并设置一个新的定时器。当延迟时间到达后，执行原始函数，并使用 apply 或 call 来保留正确的 this 指向和参数。",
      "explanation": "防抖是前端性能优化的常用技巧，用于处理高频触发的事件（如窗口resize、输入框搜索），核心在于利用 setTimeout 和 clearTimeout。",
      "test_cases": "[{\"input\": \"场景：一个函数 logFn 在 500ms 的防抖设置下，在第 0ms、100ms 和 200ms 被连续调用。\", \"expected_output\": \"logFn 应该只在第 700ms (200ms + 500ms) 时被执行一次。\"}]",
      "external_platform": "lodash",
      "external_id": "debounce"
    },
    {
      "title": "扁平数组转树形结构",
      "content": "给定一个扁平的 item 数组，其中每个 item 对象包含 id 和 parentId 属性，请编写一个函数将其转换为树形结构。根节点的 parentId 为 null 或一个不存在于任何 item 的 id 中的值。",
      "question_type": "coding",
      "difficulty": "medium",
      "estimated_time": 35,
      "knowledge_point_id": 8,
      "programming_language": "javascript",
      "starter_code": "function arrayToTree(items) {\n  const result = [];\n  const itemMap = {};\n\n  // 请在这里实现你的代码\n\n  return result;\n}",
      "correct_answer": "使用哈希表（Map/Object）进行优化。首先遍历一次数组，将所有 item 以 id 为键存入 Map 中，方便快速查找。第二次遍历数组，通过每个 item 的 parentId 从 Map 中找到其父节点，并将当前 item 添加到父节点的 children 数组中。最后找出根节点（parentId 为 null 或不存在的）即可。",
      "explanation": "这是前端处理后端返回数据时的常见需求，使用 Map 可以将查找父节点的时间复杂度从 O(n) 降低到 O(1)，从而使总时间复杂度保持在 O(n)。",
      "test_cases": "[{\"input\": \"[{\\\"id\\\":1,\\\"parentId\\\":null},{\\\"id\\\":2,\\\"parentId\\\":1},{\\\"id\\\":3,\\\"parentId\\\":1},{\\\"id\\\":4,\\\"parentId\\\":2}]\", \"expected_output\": \"[{\\\"id\\\":1,\\\"parentId\\\":null,\\\"children\\\":[{\\\"id\\\":2,\\\"parentId\\\":1,\\\"children\\\":[{\\\"id\\\":4,\\\"parentId\\\":2,\\\"children\\\":[]}]},{\\\"id\\\":3,\\\"parentId\\\":1,\\\"children\\\":[]}]}]\"}]"
    },
    {
      "title": "并发任务处理器",
      "content": "使用 Golang 实现一个并发任务处理器。你需要创建一个函数 `RunTasks`，它接收一个任务列表（`tasks`，每个任务是一个函数），以及一个并发数 `concurrency`。函数需要并发地执行这些任务，但要确保同时运行的 Goroutine 数量不超过 `concurrency`。",
      "question_type": "coding",
      "difficulty": "hard",
      "estimated_time": 40,
      "knowledge_point_id": 10,
      "programming_language": "golang",
      "starter_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// RunTasks 执行任务，并控制并发数量\nfunc RunTasks(tasks []func(), concurrency int) {\n\tvar wg sync.WaitGroup\n\t// 使用带缓冲的 channel 来控制并发\n\tsem := make(chan struct{}, concurrency)\n\n\tfor _, task := range tasks {\n\t\twg.Add(1)\n\t\t// 请在这里实现核心并发控制逻辑\n\t}\n\n\twg.Wait()\n}\n\nfunc main() {\n\t// 测试用例\n\ttasks := []func(){\n\t\tfunc() { fmt.Println(\"Task 1 done\"); time.Sleep(1 * time.Second) },\n\t\tfunc() { fmt.Println(\"Task 2 done\"); time.Sleep(1 * time.Second) },\n\t\tfunc() { fmt.Println(\"Task 3 done\"); time.Sleep(1 * time.Second) },\n\t\tfunc() { fmt.Println(\"Task 4 done\"); time.Sleep(1 * time.Second) },\n\t\tfunc() { fmt.Println(\"Task 5 done\"); time.Sleep(1 * time.Second) },\n\t}\n\n\tRunTasks(tasks, 2)\n\tfmt.Println(\"All tasks completed.\")\n}",
      "correct_answer": "核心是利用一个带缓冲的 channel 作为信号量。在启动一个 Goroutine 执行任务前，先向 channel 发送一个值（`sem <- struct{}`）。如果 channel 已满（达到并发上限），则该操作会阻塞。任务执行完毕后，从 channel 中接收一个值（`<-sem`），以释放一个“槽位”供其他任务使用。同时使用 `sync.WaitGroup` 来等待所有任务完成。",
      "explanation": "使用带缓冲的 Channel 作为信号量是 Go 中控制并发量的经典模式，它比使用锁有更好的性能和更简洁的表达。",
      "test_cases": "[{\"input\": \"tasks 列表包含5个耗时1秒的任务，concurrency 设置为2\", \"expected_output\": \"任务会分批执行，总耗时约3秒，而不是5秒。控制台会先打印2个任务完成，再打印2个，最后打印1个。\"}]"
    }
  ],
  "practical_problems": [
    {
      "title": "设计一个高复用性的 Modal (弹窗) 组件",
      "content": "请设计一个通用的 Modal 组件（可以基于 Vue 或 React）。你需要从 API 设计的角度出发，考虑它应该接收哪些 props (属性) 来控制其行为（如显示/隐藏、标题、内容、样式），以及它应该对外暴露哪些 events/callbacks (事件)（如关闭、确认、打开后）。同时，请讨论如何优雅地处理组件的内容分发（即如何让使用者自定义弹窗的主体、头部和尾部）。",
      "question_type": "practical",
      "difficulty": "medium",
      "estimated_time": 40,
      "knowledge_point_id": 1,
      "correct_answer": "API 设计应包括：1. **Props**: 使用 `v-model` 或 `isOpen` Prop 控制可见性；`title` Prop 定义标题；`width`, `top` 等 Prop 控制样式；`closeOnClickModal` Prop 控制点击遮罩是否关闭。 2. **Events/Callbacks**: 暴露 `onConfirm`, `onCancel`, `onOpened` 等事件/回调函数与父组件通信。 3. **内容分发**: 使用 Vue 的 `slot` 机制（如 `header`, `footer` 具名插槽和 `default` 默认插槽）或 React 的 `children` Prop (配合 compound components 模式) 来实现高度灵活的内容定制。",
      "explanation": "一个优秀的通用组件需要有灵活的 API 设计和清晰的职责划分。通过 props 控制行为，通过 events/callbacks 与外部通信，通过 slots/children 接受内容，这是现代前端组件设计的核心思想。"
    },
    {
      "title": "设计一个高并发 API 网关的限流器",
      "content": "请为部署在服务网关上的 API 设计一个高并发限流器。你需要选择一种具体的限流算法（如令牌桶、漏桶、固定窗口或滑动窗口），并详细阐述其工作原理、优缺点。在 Golang 环境下，你会如何利用其并发特性（goroutine 和 channel）来实现你所选择的算法？最后，请简要讨论在分布式环境下，如何扩展你的设计以实现全局限流。",
      "question_type": "practical",
      "difficulty": "hard",
      "estimated_time": 50,
      "knowledge_point_id": 10,
      "correct_answer": "首选**令牌桶算法**，因为它允许请求的突发。原理：系统以恒定速率向桶里放入令牌，处理请求时需先从桶里获取一个令牌，无令牌则拒绝。**Go 单机实现**：可以使用一个带缓冲的 channel 模拟令牌桶，channel 容量是桶的大小；一个独立的 goroutine 使用 `time.Ticker` 定期向 channel 中填充令牌。处理请求的 goroutine 尝试从 channel 非阻塞地获取令牌，成功则放行，失败则拒绝。**分布式扩展**：可使用 Redis + Lua 脚本。利用 Redis 的 `INCR`、`EXPIRE` 等原子操作在一个 key 中记录请求数（用于窗口算法）或利用 `LIST` 作为令牌桶来实现，Lua 脚本保证操作的原子性，从而在多个网关实例间共享限流状态。",
      "explanation": "限流是保证后端服务稳定性的关键。令牌桶算法是功能最全面的算法之一。Go 的 channel 和 ticker 天然适合实现此模型。分布式限流则必须依赖 Redis 等外部集中式存储来同步状态。"
    }
  ]
}