<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>å›¾åƒæ ‡æ³¨å·¥å…· - Flaskç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
      rel="stylesheet"
    />
    <style>
      /* ç°ä»£åŒ–UIæ ·å¼ */
      :root {
        --primary-bg: #f8fafc;
        --secondary-bg: #ffffff;
        --accent-color: #3b82f6;
        --accent-hover: #2563eb;
        --text-primary: #1e293b;
        --text-secondary: #64748b;
        --border-color: #e2e8f0;
        --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
        --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        --radius-sm: 0.375rem;
        --radius-md: 0.5rem;
        --radius-lg: 0.75rem;
        --radius-xl: 1rem;
      }
      
      body {
        font-family: "Inter", "SF Pro Display", "Helvetica Neue", "Arial", sans-serif;
        color: var(--text-primary);
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        margin: 0;
        padding: 0;
      }
      
      .sidebar {
        width: 320px;
        background: var(--secondary-bg);
        border-radius: 0 var(--radius-xl) var(--radius-xl) 0;
        box-shadow: var(--shadow-lg);
        backdrop-filter: blur(10px);
        border-right: 1px solid var(--border-color);
      }
      
      .editor-pane {
        flex-grow: 1;
        background: var(--primary-bg);
        margin: 16px;
        margin-left: 0;
        border-radius: var(--radius-xl);
        box-shadow: var(--shadow-lg);
        overflow: hidden;
      }
      
      .canvas-container {
        position: relative;
        width: calc(100% - 32px);
        height: calc(100% - 32px);
        margin: 16px;
        overflow: hidden;
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-lg);
        background: 
          linear-gradient(45deg, #e5e7eb 25%, transparent 25%), 
          linear-gradient(-45deg, #e5e7eb 25%, transparent 25%), 
          linear-gradient(45deg, transparent 75%, #e5e7eb 75%), 
          linear-gradient(-45deg, transparent 75%, #e5e7eb 75%);
        background-size: 20px 20px;
        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        touch-action: none;
      }
      
      #baseCanvas,
      #drawingCanvas,
      #maskCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform-origin: top left;
        border-radius: var(--radius-md);
      }
      
      #baseCanvas {
        background: white;
        z-index: 1;
      }
      
      #drawingCanvas {
        z-index: 2;
      }
      
      #maskCanvas {
        z-index: 3;
      }
      
      #maskCanvas {
        opacity: 0.5;
        mix-blend-mode: multiply;
        pointer-events: none;
      }
      
      .file-item,
      .folder-item {
        cursor: pointer;
        padding: 12px 16px;
        border-radius: var(--radius-md);
        transition: all 0.2s ease;
        margin: 4px 0;
        background: var(--primary-bg);
        border: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .file-item:hover,
      .folder-item:hover {
        background: #f1f5f9;
        transform: translateY(-1px);
        box-shadow: var(--shadow-sm);
      }
      
      .file-item.active {
        background: linear-gradient(135deg, var(--accent-color), var(--accent-hover));
        color: white;
        box-shadow: var(--shadow-md);
        transform: translateY(-1px);
      }
      .folder-header {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .folder-content {
        padding-left: 20px;
      }
      .tool-btn {
        background: var(--secondary-bg);
        color: var(--text-secondary);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        transition: all 0.2s ease;
        box-shadow: var(--shadow-sm);
        min-width: 44px;
        min-height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .tool-btn:hover {
        background: var(--primary-bg);
        transform: translateY(-1px);
        box-shadow: var(--shadow-md);
        color: var(--text-primary);
      }
      
      .tool-btn.active {
        background: linear-gradient(135deg, var(--accent-color), var(--accent-hover));
        color: white;
        box-shadow: var(--shadow-md);
        transform: translateY(-1px);
      }
      .modal-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }
      .modal-content {
        background: var(--secondary-bg);
        padding: 2rem;
        border-radius: var(--radius-xl);
        max-width: 500px;
        text-align: center;
        box-shadow: var(--shadow-lg);
        border: 1px solid var(--border-color);
      }
      
      /* æ©¡çš®æ“¦é¢„è§ˆåœ† - ç°ä»£åŒ–æ ·å¼ */
      .eraser-preview {
        position: absolute;
        border: 3px solid #ef4444;
        border-radius: 50%;
        pointer-events: none;
        background-color: rgba(239, 68, 68, 0.1);
        display: none;
        z-index: 10;
        box-shadow: 0 0 20px rgba(239, 68, 68, 0.3);
      }
      
      /* ç”»ç¬”é¢„è§ˆåœ† - ç°ä»£åŒ–æ ·å¼ */
      .brush-preview {
        position: absolute;
        border: 3px solid #22c55e;
        border-radius: 50%;
        pointer-events: none;
        background-color: rgba(34, 197, 94, 0.1);
        display: none;
        z-index: 10;
        box-shadow: 0 0 20px rgba(34, 197, 94, 0.3);
      }
      
      /* ç¦ç”¨çŠ¶æ€çš„æ§ä»¶æ ·å¼ */
      input:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      
      /* æ±‰å ¡èœå•æŒ‰é’®æ ·å¼ */
      .hamburger-menu {
        position: fixed;
        top: 50px;
        left: 300px;
        z-index: 1001;
        display: none;
        background-color: var(--secondary-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 9px;
        color: var(--text-secondary);
        cursor: pointer;
        transition: all 0.3s ease;
      }
      
      .hamburger-menu:hover {
        background-color: var(--primary-bg);
      }
      
      /* è’™ç‰ˆæ¨¡å¼ä¸‹çš„æš—åŒ–æ•ˆæœ */
      .mask-mode .editor-pane {
        background: var(--secondary-bg);
      }
      .mask-mode .canvas-container {
        background: 
          linear-gradient(45deg, #e5e7eb 25%, transparent 25%), 
          linear-gradient(-45deg, #e5e7eb 25%, transparent 25%), 
          linear-gradient(45deg, transparent 75%, #e5e7eb 75%), 
          linear-gradient(-45deg, transparent 75%, #e5e7eb 75%);
        background-size: 20px 20px;
        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
      }
      .mask-mode #baseCanvas {
        filter: brightness(0.5);
      }
      
      /* ç°ä»£åŒ–æ§ä»¶æ ·å¼ */
      select:focus, input:focus, textarea:focus {
        outline: none;
        border-color: var(--accent-color);
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
      }
      
      /* åœ†å½¢çŠ¶æ€æŒ‡ç¤ºå™¨ */
      .status-indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 6px;
      }
      
      .status-indicator.ready {
        background: #10b981;
      }
      
      .status-indicator.loading {
        background: #f59e0b;
        animation: pulse 1.5s infinite;
      }
      
      .status-indicator.error {
        background: #ef4444;
      }
      
      /* ç°ä»£åŒ–å·¥å…·æ åˆ†ç»„ */
      .toolbar-group {
        background: var(--secondary-bg);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-lg);
        padding: 8px;
        display: flex;
        align-items: center;
        gap: 8px;
        box-shadow: var(--shadow-sm);
      }
      
      /* ç°ä»£åŒ–æŒ‰é’®æ ·å¼ */
      .modern-btn {
        background: linear-gradient(135deg, var(--accent-color), var(--accent-hover));
        color: white;
        border: none;
        border-radius: var(--radius-lg);
        padding: 12px 24px;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: var(--shadow-md);
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .modern-btn:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-lg);
      }
      
      .modern-btn.success {
        background: linear-gradient(135deg, #10b981, #059669);
      }
      
      .modern-btn.purple {
        background: linear-gradient(135deg, #8b5cf6, #7c3aed);
      }
      
      /* å·¥å…·æ æŒ‰é’®çš„ç‰¹æ®Šé¢œè‰²å˜ä½“ */
      .tool-btn.success-btn {
        background: linear-gradient(135deg, #10b981, #059669);
        color: white;
      }
      
      .tool-btn.success-btn:hover {
        background: linear-gradient(135deg, #059669, #047857);
        transform: translateY(-1px);
      }
      
      .tool-btn.purple-btn {
        background: linear-gradient(135deg, #8b5cf6, #7c3aed);
        color: white;
      }
      
      .tool-btn.purple-btn:hover {
        background: linear-gradient(135deg, #7c3aed, #6d28d9);
        transform: translateY(-1px);
      }
      
      /* ç§»åŠ¨ç«¯é€‚é… */
      @media (max-width: 2290px) {
        .hamburger-menu {
          display: block;
        }
        
        .sidebar {
          position: fixed;
          top: 0;
          left: -320px;
          width: 300px;
          height: 100vh;
          z-index: 1000;
          transition: left 0.3s ease;
          border-right: 1px solid var(--border-color);
        }
        
        .sidebar.show {
          left: 0;
        }
        
        .editor-pane {
          width: 100vw;
          margin-left: 0;
          margin: 8px;
        }
        
        .canvas-container {
          height: calc(100vh - 120px);
          margin: 8px;
        }
      }
      
      /* iPad æ¨ªå±é€‚é… */
      @media (min-width: 1491px) and (max-width: 2290px) and (orientation: landscape) {
        .sidebar {
          width: 250px;
        }
        
        .tool-btn {
          padding: 6px;
        }
        
        .flex.items-center.bg-gray-600 {
          padding: 4px 6px;
        }
        
        .flex.items-center.bg-gray-600 label {
          font-size: 12px;
        }
      }

      /* Pythonæ¥å£æ‚¬æµ®æŒ‰é’® */
      .python-interface-btn {
        position: fixed;
        bottom: 24px;
        right: 24px;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background-color: var(--accent-color);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
        cursor: pointer;
        z-index: 999;
        transition: all 0.3s ease;
      }

      .python-interface-btn:hover {
        background-color: var(--accent-hover);
        transform: translateY(-2px);
        box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1), 0 4px 6px rgba(0, 0, 0, 0.05);
      }

      .python-interface-btn i {
        font-size: 24px;
      }

      /* Pythonæ¥å£æ‚¬æµ®çª— */
      .python-modal {
        position: fixed;
        top: 80px;
        left: 80px;
        width: 480px;
        height: 600px;
        min-width: 380px;
        min-height: 400px;
        background: linear-gradient(145deg, #ffffff, #f8fafc);
        border-radius: 16px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15), 0 8px 16px rgba(0, 0, 0, 0.1);
        z-index: 1002;
        display: none;
        border: 1px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(20px);
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }

      .python-modal.open {
        display: flex;
        flex-direction: column;
        animation: modalSlideIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      @keyframes modalSlideIn {
        from {
          opacity: 0;
          transform: scale(0.9) translateY(-20px);
        }
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      /* æ‚¬æµ®çª—æ ‡é¢˜æ  */
      .modal-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 16px 24px;
        border-radius: 16px 16px 0 0;
        cursor: move;
        display: flex;
        justify-content: space-between;
        align-items: center;
        user-select: none;
        font-weight: 600;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        position: relative;
      }

      .modal-header::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 100%);
        border-radius: 16px 16px 0 0;
        pointer-events: none;
      }

      .modal-header h2 {
        margin: 0;
        font-size: 1.2rem;
        display: flex;
        align-items: center;
        gap: 10px;
        font-weight: 600;
        letter-spacing: -0.02em;
      }

      .modal-header h2 i {
        font-size: 1.1em;
        opacity: 0.9;
      }

      .modal-controls {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .modal-control-btn {
        width: 28px;
        height: 28px;
        border: none;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.15);
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        font-size: 13px;
        backdrop-filter: blur(10px);
      }

      .modal-control-btn:hover {
        background: rgba(255, 255, 255, 0.25);
        transform: scale(1.05);
      }

      .modal-control-btn.close:hover {
        background: #ef4444;
        box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
      }

      .modal-control-btn.minimize:hover {
        background: #f59e0b;
        box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
      }

      /* æ‚¬æµ®çª—å†…å®¹åŒºåŸŸ */
      .modal-body {
        flex: 1;
        padding: 24px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 20px;
        background: rgba(255, 255, 255, 0.5);
      }

      /* ç¼©æ”¾æ‰‹æŸ„ */
      .resize-handle {
        position: absolute;
        bottom: 0;
        right: 0;
        width: 24px;
        height: 24px;
        cursor: nw-resize;
        background: linear-gradient(-45deg, transparent 0%, transparent 35%, rgba(0,0,0,0.1) 35%, rgba(0,0,0,0.1) 65%, transparent 65%);
        background-size: 6px 6px;
        border-radius: 0 0 16px 0;
        opacity: 0.6;
        transition: opacity 0.2s ease;
      }

      .resize-handle:hover {
        opacity: 1;
      }

      /* AIåŠ©æ‰‹æ ·å¼ */
      .ai-chat-container {
        display: flex;
        flex-direction: column;
        height: 100%;
        gap: 16px;
      }

      .chat-messages {
        flex: 1;
        background: rgba(255, 255, 255, 0.8);
        border-radius: 12px;
        padding: 20px;
        overflow-y: auto;
        min-height: 280px;
        border: 1px solid rgba(0, 0, 0, 0.08);
        backdrop-filter: blur(10px);
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
      }

      .chat-message {
        margin-bottom: 16px;
        padding: 12px 16px;
        border-radius: 12px;
        max-width: 85%;
        line-height: 1.5;
        font-size: 14px;
        position: relative;
        animation: messageSlideIn 0.3s ease-out;
      }

      @keyframes messageSlideIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .chat-message.user {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        margin-left: auto;
        text-align: right;
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
      }

      .chat-message.user::before {
        content: '';
        position: absolute;
        right: -6px;
        top: 50%;
        transform: translateY(-50%);
        width: 0;
        height: 0;
        border-left: 6px solid #764ba2;
        border-top: 6px solid transparent;
        border-bottom: 6px solid transparent;
      }

      .chat-message.assistant {
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid rgba(0, 0, 0, 0.08);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        color: #374151;
      }

      .chat-message.assistant::before {
        content: '';
        position: absolute;
        left: -6px;
        top: 50%;
        transform: translateY(-50%);
        width: 0;
        height: 0;
        border-right: 6px solid rgba(255, 255, 255, 0.9);
        border-top: 6px solid transparent;
        border-bottom: 6px solid transparent;
      }

      .chat-input-area {
        display: flex;
        gap: 12px;
        align-items: flex-end;
        background: rgba(255, 255, 255, 0.8);
        padding: 16px;
        border-radius: 12px;
        border: 1px solid rgba(0, 0, 0, 0.08);
        backdrop-filter: blur(10px);
      }

      .chat-input {
        flex: 1;
        min-height: 44px;
        max-height: 120px;
        padding: 12px 16px;
        border: 1px solid rgba(0, 0, 0, 0.1);
        border-radius: 10px;
        resize: none;
        font-family: inherit;
        font-size: 14px;
        background: rgba(255, 255, 255, 0.9);
        transition: all 0.2s ease;
        line-height: 1.4;
      }

      .chat-input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        background: white;
      }

      .chat-input::placeholder {
        color: #9ca3af;
      }

      .send-btn {
        padding: 12px 16px;
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 500;
        transition: all 0.2s ease;
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        min-width: 48px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .send-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
      }

      .send-btn:active {
        transform: translateY(0);
      }

      .send-btn:disabled {
        background: #d1d5db;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      /* è¾“å…¥æ§åˆ¶æŒ‰é’® */
      .input-controls {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .input-btn {
        width: 40px;
        height: 40px;
        border: none;
        border-radius: 8px;
        background: rgba(102, 126, 234, 0.1);
        color: #667eea;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
      }

      .input-btn:hover {
        background: rgba(102, 126, 234, 0.2);
        transform: translateY(-1px);
      }

      .input-btn.active {
        background: #667eea;
        color: white;
      }

      /* è¯­éŸ³å½•åˆ¶çŠ¶æ€ */
      .voice-recording {
        padding: 12px;
        background: rgba(239, 68, 68, 0.1);
        border-radius: 8px;
        margin-bottom: 12px;
      }

      .recording-indicator {
        display: flex;
        align-items: center;
        gap: 12px;
        color: #ef4444;
        font-weight: 500;
      }

      .pulse-dot {
        width: 12px;
        height: 12px;
        background: #ef4444;
        border-radius: 50%;
        animation: pulse 1.5s infinite;
      }

      .stop-btn {
        padding: 6px 12px;
        background: #ef4444;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s ease;
      }

      .stop-btn:hover {
        background: #dc2626;
      }

      /* æ–‡ä»¶é¢„è§ˆåŒºåŸŸ */
      .file-preview {
        margin-bottom: 12px;
        border: 1px solid rgba(0, 0, 0, 0.1);
        border-radius: 8px;
        overflow: hidden;
      }

      .preview-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        background: rgba(0, 0, 0, 0.05);
        font-size: 12px;
        font-weight: 500;
      }

      .clear-btn {
        padding: 4px 8px;
        background: #ef4444;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 11px;
      }

      .preview-content {
        padding: 12px;
        max-height: 120px;
        overflow-y: auto;
      }

      .file-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px;
        background: rgba(0, 0, 0, 0.02);
        border-radius: 4px;
        margin-bottom: 6px;
        font-size: 12px;
      }

      .file-item:last-child {
        margin-bottom: 0;
      }

      .file-icon {
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #667eea;
        color: white;
        border-radius: 4px;
        font-size: 10px;
      }

      .file-info {
        flex: 1;
      }

      .file-name {
        font-weight: 500;
        color: var(--text-primary);
      }

      .file-size {
        color: var(--text-secondary);
        font-size: 10px;
      }

      .form-group {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .form-group label {
        font-weight: 500;
        color: var(--text-secondary);
        font-size: 0.9rem;
      }

      .form-group select,
      .form-group input,
      .form-group textarea {
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        background-color: var(--primary-bg);
        color: var(--text-primary);
        font-size: 0.9rem;
      }

      .form-group select:focus,
      .form-group input:focus,
      .form-group textarea:focus {
        outline: none;
        border-color: var(--accent-color);
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
      }

      .button-group {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        margin-top: 16px;
        padding-top: 16px;
        border-top: 1px solid var(--border-color);
      }

      .btn-primary {
        background-color: var(--accent-color);
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
        font-size: 0.9rem;
        transition: background 0.2s;
      }

      .btn-primary:hover {
        background-color: var(--accent-hover);
      }

      .btn-secondary {
        background-color: var(--primary-bg);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
        font-size: 0.9rem;
        transition: all 0.2s;
      }

      .btn-secondary:hover {
        background-color: var(--secondary-bg);
        border-color: var(--accent-color);
      }

      /* APIè°ƒç”¨çŠ¶æ€æŒ‡ç¤ºå™¨ */
      .api-status {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 8px;
      }

      .api-status.connected {
        background-color: #10b981;
      }

      .api-status.disconnected {
        background-color: #ef4444;
      }

      .api-status.connecting {
        background-color: #f59e0b;
        animation: pulse 1.5s infinite;
      }

      @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
      }
      
      /* æ–‡ä»¶ä¸Šä¼ åŒºåŸŸ - ç°ä»£åŒ–æ ·å¼ */
      .file-upload-area {
        border: 2px dashed var(--border-color);
        border-radius: var(--radius-lg);
        padding: 2rem 1rem;
        text-align: center;
        cursor: pointer;
        margin-bottom: 1rem;
        transition: all 0.3s ease;
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.02), rgba(147, 51, 234, 0.02));
      }
      
      .file-upload-area:hover {
        border-color: var(--accent-color);
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.05), rgba(147, 51, 234, 0.05));
        transform: translateY(-2px);
        box-shadow: var(--shadow-md);
      }
      
      .file-upload-area i {
        font-size: 2.5rem;
        margin-bottom: 0.5rem;
        color: var(--accent-color);
      }
      
      .file-upload-area p {
        margin: 0;
        color: var(--text-secondary);
        font-weight: 500;
      }
      
      /* ç°ä»£åŒ–æ»šåŠ¨æ¡ */
      ::-webkit-scrollbar {
        width: 6px;
      }
      
      ::-webkit-scrollbar-track {
        background: var(--primary-bg);
        border-radius: 3px;
      }
      
      ::-webkit-scrollbar-thumb {
        background: var(--border-color);
        border-radius: 3px;
      }
      
      ::-webkit-scrollbar-thumb:hover {
        background: var(--text-secondary);
      }
    </style>
  </head>
  <body class="flex h-screen overflow-hidden">
    <!-- æ±‰å ¡èœå•æŒ‰é’® (ä»…åœ¨ç§»åŠ¨ç«¯æ˜¾ç¤º) -->
    <button id="hamburger-menu" class="hamburger-menu" title="æ˜¾ç¤º/éšè—ä¾§è¾¹æ ">
      <i class="fas fa-bars"></i>
    </button>
    
    <!-- Sidebar -->
    <aside class="sidebar flex flex-col p-6 space-y-6">
      <div class="text-center">
        <h1 class="text-2xl font-bold" style="background: linear-gradient(135deg, var(--accent-color), var(--accent-hover)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">PhotoRemark</h1>
        <p class="text-sm" style="color: var(--text-secondary); margin-top: 4px;">æ™ºèƒ½å›¾åƒæ ‡æ³¨å·¥å…·</p>
      </div>
      <div class="flex flex-col space-y-2">
        <div class="p-4 rounded-lg" style="background: var(--primary-bg); border: 1px solid var(--border-color);">
          <label for="wrinkleTypeSelect" class="text-sm font-semibold mb-2 block" style="color: var(--text-primary);"
            >ğŸ·ï¸ çš±çº¹ç±»å‹</label
          >
          <select
            id="wrinkleTypeSelect"
            class="w-full py-3 px-4 rounded-lg border focus:outline-none focus:ring-2 transition-all"
            style="background: var(--secondary-bg); border-color: var(--border-color); color: var(--text-primary);"
          >
            <option value="">è¯·é€‰æ‹©çš±çº¹ç±»å‹</option>
          </select>
        </div>
      </div>

      <div class="flex-grow">
        <div class="mb-4">
          <h3 class="text-sm font-semibold mb-3" style="color: var(--text-primary);">ğŸ“ æ–‡ä»¶ç®¡ç†</h3>
          <div id="file-tree" class="space-y-2 overflow-y-auto pr-2 max-h-96">
            <p style="color: var(--text-secondary); font-size: 14px;">æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„æˆ–ç‚¹å‡»å¯¼å…¥æŒ‰é’®</p>
          </div>
        </div>
        
        <div class="p-4 rounded-lg" style="background: var(--primary-bg); border: 1px solid var(--border-color);">
          <h3 class="text-sm font-semibold mb-2" style="color: var(--text-primary);">ğŸ“Š çŠ¶æ€ä¿¡æ¯</h3>
          <div class="space-y-1">
            <p class="text-xs" style="color: var(--text-secondary);">çŠ¶æ€: <span class="status-indicator ready"></span><span id="status-text" class="font-medium" style="color: var(--accent-color);">å°±ç»ª</span></p>
            <p id="source-info" class="text-xs" style="color: var(--text-secondary);"></p>
          </div>
        </div>
      </div>
    </aside>

    <!-- Editor Pane -->
    <main class="editor-pane flex flex-col">
      <!-- Toolbar -->
      <div
        class="p-2 flex items-center justify-between border-b" style="background: var(--secondary-bg); border-color: var(--border-color); min-height: 60px;"
      >
        <!-- å·¦ä¾§å·¥å…·æ  -->
        <div class="flex items-center gap-1">
          <!-- ç»˜å›¾å·¥å…·ç»„ -->
          <div class="toolbar-group">
            <button
              id="tool-pan"
              class="tool-btn"
              title="ç§»åŠ¨ (V)"
            >
              <i class="fas fa-hand-paper fa-fw"></i>
            </button>
            <button
              id="tool-pencil"
              class="tool-btn active"
              title="ç”»ç¬” (B)"
            >
              <i class="fas fa-pencil-alt fa-fw"></i>
            </button>
            <button
              id="tool-rectangle"
              class="tool-btn"
              title="çŸ©å½¢ (R)"
            >
              <i class="fas fa-vector-square fa-fw"></i>
            </button>
            <button
              id="tool-polygon"
              class="tool-btn"
              title="å¤šè¾¹å½¢ (P)"
            >
              <i class="fas fa-draw-polygon fa-fw"></i>
            </button>
            <button
              id="tool-eraser"
              class="tool-btn"
              title="æ©¡çš®æ“¦ (E)"
            >
              <i class="fas fa-eraser fa-fw"></i>
            </button>
            <button
              id="tool-mask"
              class="tool-btn"
              title="è’™ç‰ˆå·¥å…· (T)"
            >
              <i class="fas fa-highlighter fa-fw"></i>
            </button>
          </div>
          
          <!-- ç»˜å›¾å±æ€§ç»„ -->
          <div class="toolbar-group">
            <label for="brush-size" class="text-xs font-medium" style="color: var(--text-secondary);">å¤§å°</label>
            <input
              type="range"
              id="brush-size"
              min="1"
              max="100"
              value="5"
              class="w-12"
              style="accent-color: var(--accent-color);"
            />
          </div>
          
          <div class="toolbar-group" id="color-container">
            <label for="brush-color" class="text-xs font-medium" style="color: var(--text-secondary);">é¢œè‰²</label>
            <input type="color" id="brush-color" value="#ff0000" class="w-6 h-6 rounded border" style="border-color: var(--border-color);" />
          </div>
          
          <div class="toolbar-group" id="mask-color-container">
            <label for="mask-color" class="text-xs font-medium" style="color: var(--text-secondary);">è’™ç‰ˆ</label>
            <input type="color" id="mask-color" value="#ffff00" class="w-6 h-6 rounded border" style="border-color: var(--border-color);" />
          </div>
          
          <div class="toolbar-group" id="layer-opacity-container">
            <label for="layer-opacity" class="text-xs font-medium" style="color: var(--text-secondary);">æ ‡æ³¨</label>
            <input
              type="range"
              id="layer-opacity"
              min="0"
              max="100"
              step="10"
              value="100"
              class="w-10"
              style="accent-color: var(--accent-color);"
            />
            <span id="layer-opacity-value" class="text-xs font-medium" style="color: var(--text-primary);">100%</span>
          </div>
          
          <div class="toolbar-group" id="mask-opacity-container">
            <label for="mask-opacity" class="text-xs font-medium" style="color: var(--text-secondary);">è’™ç‰ˆ</label>
            <input
              type="range"
              id="mask-opacity"
              min="0"
              max="100"
              value="50"
              class="w-10"
              style="accent-color: var(--accent-color);"
            />
            <span id="mask-opacity-value" class="text-xs font-medium" style="color: var(--text-primary);">50%</span>
          </div>
        </div>
        
        <!-- ä¸­é—´ç¼©æ”¾æ§åˆ¶ç»„ -->
        <div class="toolbar-group">
          <button id="zoom-out" class="tool-btn" title="ç¼©å°">
            <i class="fas fa-search-minus fa-fw"></i>
          </button>
          <span id="zoom-level" class="text-xs w-8 text-center font-semibold px-1 py-1 rounded" style="color: var(--text-primary); background: var(--primary-bg);">100%</span>
          <button id="zoom-in" class="tool-btn" title="æ”¾å¤§">
            <i class="fas fa-search-plus fa-fw"></i>
          </button>
          <button
            id="zoom-reset"
            class="tool-btn"
            title="é‡ç½®ç¼©æ”¾"
          >
            <i class="fas fa-expand fa-fw"></i>
          </button>
        </div>
        
        <!-- å³ä¾§æ“ä½œæŒ‰é’®ç»„ -->
        <div class="flex items-center gap-1">
          <button
            id="toggle-mask"
            class="tool-btn"
            title="åˆ‡æ¢è’™ç‰ˆ (M)"
          >
            <i class="fas fa-layer-group fa-fw"></i>
          </button>
          <button
            id="clear-mask"
            class="tool-btn"
            title="æ¸…é™¤è’™ç‰ˆ"
          >
            <i class="fas fa-trash-alt fa-fw"></i>
          </button>
          <button
            id="saveBtn"
            class="tool-btn success-btn"
            title="å¯¼å‡ºæ ‡æ³¨"
          >
            <i class="fas fa-download fa-fw"></i>
          </button>
          <button
            id="exportBtn"
            class="tool-btn purple-btn"
            title="å¯¼å‡ºåˆå¹¶"
          >
            <i class="fas fa-file-export fa-fw"></i>
          </button>
          <button
            id="importBtn"
            class="tool-btn"
            title="å¯¼å…¥å›¾åƒ"
          >
            <i class="fas fa-image fa-fw"></i>
          </button>
          <input id="localImageInput" type="file" accept="image/*" multiple class="hidden" />
        </div>
      </div>
      <!-- Canvas Area -->
      <div id="canvas-container" class="canvas-container">
        <canvas id="baseCanvas"></canvas>
        <canvas id="drawingCanvas"></canvas>
        <canvas id="maskCanvas"></canvas>
        <div id="eraser-preview" class="eraser-preview"></div>
        <div id="brush-preview" class="brush-preview"></div>
      </div>
    </main>

    <!-- Modal for messages -->
    <div id="modal" class="modal-backdrop hidden">
      <div class="modal-content">
        <p id="modal-message" style="color: var(--text-primary); margin-bottom: 1.5rem;"></p>
        <button
          id="modal-close"
          class="modern-btn"
        >
          å…³é—­
        </button>
      </div>
    </div>

    <!-- Pythonæ¥å£æ‚¬æµ®æŒ‰é’® -->
    <div id="python-interface-btn" class="python-interface-btn">
      <i class="fas fa-code"></i>
    </div>

    <!-- Pythonæ¥å£æ‚¬æµ®çª— -->
    <div id="python-modal" class="python-modal">
      <div class="modal-header">
        <h2><i class="fas fa-robot"></i> AI åŠ©æ‰‹</h2>
        <div class="modal-controls">
          <button class="modal-control-btn minimize" title="æœ€å°åŒ–">
            <i class="fas fa-minus"></i>
          </button>
          <button class="modal-control-btn close" title="å…³é—­">
            <i class="fas fa-times"></i>
          </button>
        </div>
      </div>
      
      <div class="modal-body">
        <div class="ai-chat-container">
          <div class="chat-messages" id="chat-messages">
            <div class="chat-message assistant">
              <strong>AIåŠ©æ‰‹:</strong> æ¬¢è¿ä½¿ç”¨AIåŠ©æ‰‹ï¼æˆ‘å¯ä»¥å¸®åŠ©æ‚¨åˆ†æå›¾åƒã€å›ç­”é—®é¢˜æˆ–ååŠ©æ ‡æ³¨å·¥ä½œã€‚
            </div>
          </div>
          
          <div class="chat-input-area">
            <div class="input-controls">
              <button id="file-upload-btn" class="input-btn" title="ä¸Šä¼ æ–‡ä»¶">
                <i class="fas fa-paperclip"></i>
              </button>
              <button id="voice-btn" class="input-btn" title="è¯­éŸ³è¾“å…¥">
                <i class="fas fa-microphone"></i>
              </button>
            </div>
            <textarea 
              id="chat-input" 
              class="chat-input" 
              placeholder="è¾“å…¥æ‚¨çš„é—®é¢˜ï¼Œæˆ–ç‚¹å‡»æŒ‰é’®ä½¿ç”¨è¯­éŸ³/æ–‡ä»¶..."
              rows="1"></textarea>
            <button id="send-btn" class="send-btn">
              <i class="fas fa-paper-plane"></i>
            </button>
            <input type="file" id="file-input" accept="image/*,audio/*" style="display: none;" multiple>
          </div>
          
          <!-- è¯­éŸ³å½•åˆ¶çŠ¶æ€ -->
          <div id="voice-recording" class="voice-recording" style="display: none;">
            <div class="recording-indicator">
              <div class="pulse-dot"></div>
              <span>æ­£åœ¨å½•éŸ³...</span>
              <button id="stop-recording" class="stop-btn">åœæ­¢</button>
            </div>
          </div>
          
          <!-- æ–‡ä»¶é¢„è§ˆåŒºåŸŸ -->
          <div id="file-preview" class="file-preview" style="display: none;">
            <div class="preview-header">
              <span>å·²é€‰æ‹©æ–‡ä»¶:</span>
              <button id="clear-files" class="clear-btn">æ¸…é™¤</button>
            </div>
            <div id="preview-content" class="preview-content"></div>
          </div>
        </div>
        
        <!-- é«˜çº§è®¾ç½®åŒºåŸŸ -->
        <details class="advanced-settings" style="margin-top: 16px;">
          <summary style="cursor: pointer; font-weight: 500; color: var(--text-secondary);">é«˜çº§è®¾ç½®</summary>
          <div style="margin-top: 12px; padding: 12px; background: var(--primary-bg); border-radius: 6px; border: 1px solid var(--border-color);">
            <div class="form-group">
              <label for="api-service">é€‰æ‹©æœåŠ¡</label>
              <select id="api-service">
                <option value="chat">æ˜Ÿç«èŠå¤©æ¨¡å‹</option>
                <option value="ocr">OCRè¯†åˆ«æœåŠ¡</option>
                <option value="voice">è¯­éŸ³äº¤äº’æœåŠ¡</option>
              </select>
            </div>
            
            <div class="form-group">
              <label for="api-endpoint">API ç«¯ç‚¹</label>
              <input type="text" id="api-endpoint" placeholder="è¯·è¾“å…¥APIç«¯ç‚¹URL" />
            </div>
            
            <div class="button-group">
              <button id="test-api-btn" class="btn-secondary">æµ‹è¯•è¿æ¥</button>
            </div>
          </div>
        </details>
      </div>
      
      <div class="resize-handle"></div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // DOM å…ƒç´ è·å–
        const wrinkleTypeSelect = document.getElementById("wrinkleTypeSelect");
        const fileTreeContainer = document.getElementById("file-tree");
        const statusText = document.getElementById("status-text");
        const sourceInfo = document.getElementById("source-info");

        const baseCanvas = document.getElementById("baseCanvas");
        const drawingCanvas = document.getElementById("drawingCanvas");
        const maskCanvas = document.getElementById("maskCanvas");
        const canvasContainer = document.getElementById("canvas-container");
        const baseCtx = baseCanvas.getContext("2d");
        const drawingCtx = drawingCanvas.getContext("2d");
        const maskCtx = maskCanvas.getContext("2d");

        const toolPan = document.getElementById("tool-pan");
        const toolPencil = document.getElementById("tool-pencil");
        const toolRectangle = document.getElementById("tool-rectangle");
        const toolPolygon = document.getElementById("tool-polygon");
        const toolEraser = document.getElementById("tool-eraser");
        const toolMask = document.getElementById("tool-mask");
        const brushSizeInput = document.getElementById("brush-size");
        const brushColorInput = document.getElementById("brush-color");
        const maskColorInput = document.getElementById("mask-color");
        const layerOpacityInput = document.getElementById("layer-opacity");
        const layerOpacityValueDisplay = document.getElementById("layer-opacity-value");
        const maskOpacityInput = document.getElementById("mask-opacity");
        const maskOpacityValueDisplay = document.getElementById("mask-opacity-value");
        const eraserPreview = document.getElementById("eraser-preview");
        const brushPreview = document.getElementById("brush-preview");

        const zoomInBtn = document.getElementById("zoom-in");
        const zoomOutBtn = document.getElementById("zoom-out");
        const zoomResetBtn = document.getElementById("zoom-reset");
        const zoomLevelDisplay = document.getElementById("zoom-level");

        const saveBtn = document.getElementById("saveBtn");
        const exportBtn = document.getElementById("exportBtn");
        const importBtn = document.getElementById("importBtn");
        const localImageInput = document.getElementById("localImageInput");
        const toggleMaskBtn = document.getElementById("toggle-mask");
        const clearMaskBtn = document.getElementById("clear-mask");

        const modal = document.getElementById("modal");
        const modalMessage = document.getElementById("modal-message");
        const modalClose = document.getElementById("modal-close");
        const hamburgerMenu = document.getElementById("hamburger-menu");
        const sidebar = document.querySelector(".sidebar");

        // Pythonæ¥å£ç›¸å…³å…ƒç´ 
        const pythonInterfaceBtn = document.getElementById("python-interface-btn");
        const pythonModal = document.getElementById("python-modal");
        const modalHeader = pythonModal.querySelector('.modal-header');
        const modalCloseBtn = pythonModal.querySelector('.modal-control-btn.close');
        const modalMinimizeBtn = pythonModal.querySelector('.modal-control-btn.minimize');
        const resizeHandle = pythonModal.querySelector('.resize-handle');
        const chatMessages = document.getElementById("chat-messages");
        const chatInput = document.getElementById("chat-input");
        const sendMessageBtn = document.getElementById("send-message-btn");
        const apiServiceSelect = document.getElementById("api-service");
        const apiEndpointInput = document.getElementById("api-endpoint");
        const testApiBtn = document.getElementById("test-api-btn");

        // åº”ç”¨çŠ¶æ€
        let state = {
          // æœ¬åœ°æ¨¡å¼æ•°æ®
          localFiles: [], // { name, dataURL, overlayData? }
          activeLocalIndex: null,
          isCanvasReady: false,
          // ç”»å¸ƒä¸äº¤äº’
          isDrawing: false,
          isPanning: false,
          isDrawingPolygon: false, // å¤šè¾¹å½¢ç»˜åˆ¶çŠ¶æ€
          lastX: 0,
          lastY: 0,
          currentTool: "pencil", // 'pencil', 'eraser', 'pan', 'rectangle', 'polygon', 'mask'
          zoom: 1,
          pan: { x: 0, y: 0 },
          imageSize: { width: 0, height: 0 },
          originalImageSize: { width: 0, height: 0 }, // åŸå§‹å›¾ç‰‡å°ºå¯¸
          originalBaseImageDataURL: null, // åŸå§‹åº•å›¾ï¼Œç”¨äºæ— æŸå¯¼å‡ºåˆå¹¶å›¾
          canvasScale: 1, // ç”»å¸ƒç¼©æ”¾æ¯”ä¾‹
          savedCanvasState: null,
          polygonPoints: [], // å¤šè¾¹å½¢é¡¶ç‚¹
          supportsPressure: false, // å‹åŠ›æ„Ÿåº”æ”¯æŒæ£€æµ‹
          isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
          // è’™ç‰ˆç›¸å…³çŠ¶æ€
          isMaskVisible: true,
          maskColor: 'rgba(255, 255, 0, 0.5)',
          maskOpacity: 50,
          // APIç›¸å…³çŠ¶æ€
          apiStatus: "disconnected", // disconnected, connecting, connected
          // APIç«¯ç‚¹é…ç½®
          apiEndpoints: {
            chat: "http://127.0.0.1:5001/chat",
            ocr: "http://127.0.0.1:6000/ocr",
            voice: "http://127.0.0.1:7000/chat"
          },
          // æ‚¬æµ®çª—çŠ¶æ€
          modalDragging: false,
          modalResizing: false,
          modalStartPos: { x: 0, y: 0 },
          modalStartSize: { width: 0, height: 0 },
          modalIsMinimized: false,
          // èŠå¤©å†å²
          chatHistory: []
        };

        // --- æ‚¬æµ®çª—æ‹–æ‹½å’Œç¼©æ”¾åŠŸèƒ½ ---
        
        // åˆå§‹åŒ–æ‚¬æµ®çª—æ‹–æ‹½åŠŸèƒ½
        function initModalDrag() {
          modalHeader.addEventListener('mousedown', startDrag);
          document.addEventListener('mousemove', drag);
          document.addEventListener('mouseup', stopDrag);
        }
        
        function startDrag(e) {
          if (e.target.closest('.modal-control-btn')) return;
          state.modalDragging = true;
          state.modalStartPos = {
            x: e.clientX - pythonModal.offsetLeft,
            y: e.clientY - pythonModal.offsetTop
          };
          pythonModal.style.cursor = 'move';
          e.preventDefault();
        }
        
        function drag(e) {
          if (!state.modalDragging && !state.modalResizing) return;
          
          if (state.modalDragging) {
            const newX = e.clientX - state.modalStartPos.x;
            const newY = e.clientY - state.modalStartPos.y;
            
            // é™åˆ¶åœ¨çª—å£èŒƒå›´å†…
            const maxX = window.innerWidth - pythonModal.offsetWidth;
            const maxY = window.innerHeight - pythonModal.offsetHeight;
            
            pythonModal.style.left = Math.max(0, Math.min(newX, maxX)) + 'px';
            pythonModal.style.top = Math.max(0, Math.min(newY, maxY)) + 'px';
          }
          
          if (state.modalResizing) {
            const newWidth = Math.max(400, e.clientX - pythonModal.offsetLeft + 10);
            const newHeight = Math.max(300, e.clientY - pythonModal.offsetTop + 10);
            
            pythonModal.style.width = newWidth + 'px';
            pythonModal.style.height = newHeight + 'px';
          }
        }
        
        function stopDrag() {
          state.modalDragging = false;
          state.modalResizing = false;
          pythonModal.style.cursor = 'default';
        }
        
        // åˆå§‹åŒ–ç¼©æ”¾åŠŸèƒ½
        function initModalResize() {
          resizeHandle.addEventListener('mousedown', startResize);
        }
        
        function startResize(e) {
          state.modalResizing = true;
          e.preventDefault();
          e.stopPropagation();
        }
        
        // æ‰“å¼€æ‚¬æµ®çª—
        function openPythonModal() {
          pythonModal.classList.add('open');
          if (state.modalIsMinimized) {
            toggleMinimize();
          }
        }
        
        // å…³é—­æ‚¬æµ®çª—
        function closePythonModal() {
          pythonModal.classList.remove('open');
        }
        
        // æœ€å°åŒ–/æ¢å¤æ‚¬æµ®çª—
        function toggleMinimize() {
          const modalBody = pythonModal.querySelector('.modal-body');
          const resizeHandle = pythonModal.querySelector('.resize-handle');
          
          if (state.modalIsMinimized) {
            // æ¢å¤
            modalBody.style.display = 'flex';
            resizeHandle.style.display = 'block';
            pythonModal.style.height = '500px';
            modalMinimizeBtn.innerHTML = '<i class="fas fa-minus"></i>';
            state.modalIsMinimized = false;
          } else {
            // æœ€å°åŒ–
            modalBody.style.display = 'none';
            resizeHandle.style.display = 'none';
            pythonModal.style.height = '50px';
            modalMinimizeBtn.innerHTML = '<i class="fas fa-window-restore"></i>';
            state.modalIsMinimized = true;
          }
        }
        
        // æµ‹è¯•APIè¿æ¥
        // async function testApiConnection() {
        //   const service = apiServiceSelect.value;
        //   const endpoint = apiEndpointInput.value;
          
        //   if (!endpoint) {
        //     updateApiResponse("é”™è¯¯: è¯·è¾“å…¥APIç«¯ç‚¹URL");
        //     return;
        //   }
          
        //   updateApiResponse("æµ‹è¯•è¿æ¥ä¸­...");
        //   setApiStatus("connecting");
          
        //   try {
        //     let testUrl = endpoint;
        //     let options = {
        //       method: 'GET',
        //       headers: {
        //         'Content-Type': 'application/json',
        //       },
        //     };
            
        //     // æ ¹æ®ä¸åŒæœåŠ¡è°ƒæ•´æµ‹è¯•URL
        //     if (service === 'chat') {
        //       testUrl = endpoint.replace('/chat', '/status');
        //     } else if (service === 'ocr') {
        //       testUrl = endpoint.replace('/ocr', '/status');
        //     } else if (service === 'voice') {
        //       testUrl = endpoint.replace('/chat', '/status');
        //     }
            
        //     const response = await fetch(testUrl, options);
            
        //     if (response.ok) {
        //       const data = await response.json();
        //       updateApiResponse(`è¿æ¥æˆåŠŸ: ${JSON.stringify(data, null, 2)}`);
        //       setApiStatus("connected");
        //     } else {
        //       updateApiResponse(`è¿æ¥å¤±è´¥: çŠ¶æ€ç  ${response.status}`);
        //       setApiStatus("disconnected");
        //     }
        //   } catch (error) {
        //     updateApiResponse(`è¿æ¥é”™è¯¯: ${error.message}`);
        //     setApiStatus("disconnected");
        //   }
        // }
        async function testApiConnection() {
          const service = apiServiceSelect.value;
          const endpoint = apiEndpointInput.value;
          
          if (!endpoint) {
            showConnectionStatus("é”™è¯¯: è¯·è¾“å…¥APIç«¯ç‚¹URL", true);
            return;
          }
          
          showConnectionStatus("æµ‹è¯•è¿æ¥ä¸­...");
          setApiStatus("connecting");
          
          try {
            // æ„å»ºå¥åº·æ£€æŸ¥URL
            let healthCheckUrl;
            if (service === 'chat') {
              healthCheckUrl = endpoint.replace('/chat', '/health');
            } else if (service === 'ocr') {
              healthCheckUrl = endpoint.replace('/ocr', '/health');
            } else if (service === 'voice') {
              healthCheckUrl = endpoint.replace('/chat', '/health');
            } else {
              throw new Error("æœªçŸ¥çš„æœåŠ¡ç±»å‹");
            }
            
            const response = await fetch(healthCheckUrl, {
              method: 'GET',
              headers: {
                'Content-Type': 'application/json',
              },
            });
            
            if (response.ok) {
              const data = await response.json();
              showConnectionStatus(`è¿æ¥æˆåŠŸ: ${data.status || 'æœåŠ¡æ­£å¸¸'}`);
              setApiStatus("connected");
              
              // æ›´æ–°APIç«¯ç‚¹é…ç½®
              state.apiEndpoints[service] = endpoint;
            } else {
              showConnectionStatus(`è¿æ¥å¤±è´¥: çŠ¶æ€ç  ${response.status}`, true);
              setApiStatus("disconnected");
            }
          } catch (error) {
            let errorMsg = `è¿æ¥é”™è¯¯: ${error.message}`;
            
            // æä¾›æ›´å…·ä½“çš„é”™è¯¯è¯Šæ–­
            if (error.message.includes('Failed to fetch')) {
              errorMsg += "\nå¯èƒ½çš„åŸå› : æœåŠ¡æœªå¯åŠ¨æˆ–ç½‘ç»œé—®é¢˜";
            }
            
            showConnectionStatus(errorMsg, true);
            setApiStatus("disconnected");
          }
        }
        
        // --- AIèŠå¤©åŠŸèƒ½ ---
        
        // å…¨å±€å˜é‡
        let mediaRecorder = null;
        let audioChunks = [];
        let selectedFiles = [];
        let isRecording = false;
        
        // å‘é€æ¶ˆæ¯ï¼ˆæ”¯æŒå¤šæ¨¡æ€ï¼‰
        async function sendMessage() {
          const message = chatInput.value.trim();
          const hasFiles = selectedFiles.length > 0;
          
          if (!message && !hasFiles) return;
          
          // æ„å»ºæ¶ˆæ¯å†…å®¹
          let messageContent = message;
          if (hasFiles) {
            const fileNames = selectedFiles.map(f => f.name).join(', ');
            messageContent += hasFiles && message ? `\n[é™„ä»¶: ${fileNames}]` : `[é™„ä»¶: ${fileNames}]`;
          }
          
          // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°èŠå¤©è®°å½•
          addMessageToChat('user', messageContent);
          chatInput.value = '';
          clearSelectedFiles();
          
          // æ˜¾ç¤ºæ­£åœ¨è¾“å…¥çŠ¶æ€
          const typingMsg = addMessageToChat('assistant', 'æ­£åœ¨å¤„ç†ä¸­...');
          const sendBtn = document.getElementById('send-btn');
          sendBtn.disabled = true;
          
          try {
            let response;
            
            if (hasFiles) {
              // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
              response = await handleFileUpload(selectedFiles, message);
            } else {
              // æ™®é€šæ–‡å­—èŠå¤©
              response = await sendTextMessage(message);
            }
            
            // ç§»é™¤æ­£åœ¨è¾“å…¥æ¶ˆæ¯ï¼Œæ·»åŠ å®é™…å›å¤
            typingMsg.remove();
            addMessageToChat('assistant', response);
            
          } catch (error) {
            typingMsg.remove();
            addMessageToChat('assistant', `æŠ±æ­‰ï¼Œå¤„ç†å¤±è´¥ï¼š${error.message}`);
          } finally {
            sendBtn.disabled = false;
          }
        }
        
        // å‘é€æ–‡å­—æ¶ˆæ¯
        async function sendTextMessage(message) {
          const endpoint = state.apiEndpoints.chat;
          const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              user_id: 'annotation_tool_user',
              message: message
            })
          });
          
          if (!response.ok) {
            throw new Error(`HTTPé”™è¯¯: ${response.status}`);
          }
          
          const data = await response.json();
          return data.reply || data.response || data.message || 'æŠ±æ­‰ï¼ŒAIæœåŠ¡æš‚æ—¶ä¸å¯ç”¨ã€‚';
        }
        
        // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
        async function handleFileUpload(files, textMessage = '') {
          const formData = new FormData();
          
          for (let file of files) {
            if (file.type.startsWith('image/')) {
              // å›¾ç‰‡æ–‡ä»¶ - ä½¿ç”¨OCR API
              formData.append('image', file);
              
              const response = await fetch('http://127.0.0.1:8000/ocr', {
                method: 'POST',
                body: formData
              });
              
              if (!response.ok) {
                throw new Error('OCRå¤„ç†å¤±è´¥');
              }
              
              const data = await response.json();
              let result = `å›¾ç‰‡è¯†åˆ«ç»“æœï¼š\n${data.text || 'æœªè¯†åˆ«åˆ°æ–‡å­—'}`;
              
              if (textMessage) {
                // å°†OCRç»“æœå’Œç”¨æˆ·é—®é¢˜ä¸€èµ·å‘é€ç»™èŠå¤©API
                const chatResponse = await sendTextMessage(`${textMessage}\n\nå›¾ç‰‡å†…å®¹ï¼š${data.text}`);
                result += `\n\nAIåˆ†æï¼š${chatResponse}`;
              }
              
              return result;
              
            } else if (file.type.startsWith('audio/')) {
              // éŸ³é¢‘æ–‡ä»¶ - ä½¿ç”¨è¯­éŸ³API
              const audioFormData = new FormData();
              audioFormData.append('audio', file);
              
              const response = await fetch('http://127.0.0.1:7000/chat', {
                method: 'POST',
                body: audioFormData
              });
              
              if (!response.ok) {
                throw new Error('è¯­éŸ³å¤„ç†å¤±è´¥');
              }
              
              const data = await response.json();
              let result = `è¯­éŸ³è¯†åˆ«ï¼š${data.text || 'æœªè¯†åˆ«åˆ°è¯­éŸ³'}`;
              
              if (data.audio_file) {
                result += `\n[AIè¯­éŸ³å›å¤å·²ç”Ÿæˆ]`;
                // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æ’­æ”¾éŸ³é¢‘çš„åŠŸèƒ½
              }
              
              return result;
            }
          }
          
          return 'æ–‡ä»¶ç±»å‹ä¸æ”¯æŒ';
        }
        
        // è¯­éŸ³å½•åˆ¶åŠŸèƒ½
        async function startVoiceRecording() {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];
            
            mediaRecorder.ondataavailable = (event) => {
              audioChunks.push(event.data);
            };
            
            mediaRecorder.onstop = async () => {
              const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
              await handleVoiceInput(audioBlob);
              stream.getTracks().forEach(track => track.stop());
            };
            
            mediaRecorder.start();
            isRecording = true;
            
            // æ˜¾ç¤ºå½•åˆ¶çŠ¶æ€
            document.getElementById('voice-recording').style.display = 'block';
            document.getElementById('voice-btn').classList.add('active');
            
          } catch (error) {
            addMessageToChat('assistant', `è¯­éŸ³å½•åˆ¶å¤±è´¥ï¼š${error.message}`);
          }
        }
        
        function stopVoiceRecording() {
          if (mediaRecorder && isRecording) {
            mediaRecorder.stop();
            isRecording = false;
            
            // éšè—å½•åˆ¶çŠ¶æ€
            document.getElementById('voice-recording').style.display = 'none';
            document.getElementById('voice-btn').classList.remove('active');
          }
        }
        
        async function handleVoiceInput(audioBlob) {
          const formData = new FormData();
          formData.append('audio', audioBlob, 'voice_input.wav');
          
          const typingMsg = addMessageToChat('assistant', 'æ­£åœ¨è¯†åˆ«è¯­éŸ³...');
          
          try {
            const response = await fetch('http://127.0.0.1:7000/chat', {
              method: 'POST',
              body: formData
            });
            
            if (!response.ok) {
              throw new Error('è¯­éŸ³è¯†åˆ«å¤±è´¥');
            }
            
            const data = await response.json();
            typingMsg.remove();
            
            // æ˜¾ç¤ºè¯†åˆ«ç»“æœ
            addMessageToChat('user', `[è¯­éŸ³] ${data.text || 'æœªè¯†åˆ«åˆ°å†…å®¹'}`);
            
            if (data.text) {
              // å°†è¯†åˆ«çš„æ–‡å­—å¡«å…¥è¾“å…¥æ¡†
              chatInput.value = data.text;
            }
            
            if (data.audio_file) {
              addMessageToChat('assistant', `è¯­éŸ³å›å¤å·²ç”Ÿæˆ [${data.audio_file}]`);
            }
            
          } catch (error) {
            typingMsg.remove();
            addMessageToChat('assistant', `è¯­éŸ³å¤„ç†å¤±è´¥ï¼š${error.message}`);
          }
        }
        
        // æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½
        function handleFileSelect(event) {
          const files = Array.from(event.target.files);
          selectedFiles = [...selectedFiles, ...files];
          updateFilePreview();
        }
        
        function updateFilePreview() {
          const previewDiv = document.getElementById('file-preview');
          const previewContent = document.getElementById('preview-content');
          
          if (selectedFiles.length === 0) {
            previewDiv.style.display = 'none';
            return;
          }
          
          previewDiv.style.display = 'block';
          previewContent.innerHTML = '';
          
          selectedFiles.forEach((file, index) => {
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            
            const icon = file.type.startsWith('image/') ? 'ğŸ–¼ï¸' : 
                        file.type.startsWith('audio/') ? 'ğŸµ' : 'ğŸ“„';
            
            fileItem.innerHTML = `
              <div class="file-icon">${icon}</div>
              <div class="file-info">
                <div class="file-name">${file.name}</div>
                <div class="file-size">${formatFileSize(file.size)}</div>
              </div>
              <button onclick="removeFile(${index})" class="clear-btn">Ã—</button>
            `;
            
            previewContent.appendChild(fileItem);
          });
        }
        
        function removeFile(index) {
          selectedFiles.splice(index, 1);
          updateFilePreview();
        }
        
        function clearSelectedFiles() {
          selectedFiles = [];
          updateFilePreview();
          document.getElementById('file-input').value = '';
        }
        
        function formatFileSize(bytes) {
          if (bytes === 0) return '0 B';
          const k = 1024;
          const sizes = ['B', 'KB', 'MB', 'GB'];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©ç•Œé¢
        function addMessageToChat(sender, message) {
          const messageDiv = document.createElement('div');
          messageDiv.className = `chat-message ${sender}`;
          
          if (sender === 'user') {
            messageDiv.innerHTML = `<strong>æ‚¨:</strong> ${message}`;
          } else {
            messageDiv.innerHTML = `<strong>AIåŠ©æ‰‹:</strong> ${message}`;
          }
          
          chatMessages.appendChild(messageDiv);
          chatMessages.scrollTop = chatMessages.scrollHeight;
          
          // ä¿å­˜åˆ°èŠå¤©å†å²
          state.chatHistory.push({ sender, message, timestamp: Date.now() });
          
          return messageDiv;
        }
        
        // å¤„ç†è¾“å…¥æ¡†å›è½¦äº‹ä»¶
        function handleChatInput(e) {
          // ä¿®å¤ç‰¹æ®Šç¬¦å·è¾“å…¥é—®é¢˜ï¼šåªåœ¨éç»„åˆè¾“å…¥çŠ¶æ€ä¸‹å¤„ç†å›è½¦
          if (e.key === 'Enter' && !e.shiftKey && !e.isComposing) {
            e.preventDefault();
            sendMessage();
          }
        }
        
        // æ ¹æ®é€‰æ‹©çš„æœåŠ¡æ›´æ–°ç«¯ç‚¹è¾“å…¥æ¡†
        function updateApiUI() {
          const service = apiServiceSelect.value;
          apiEndpointInput.value = state.apiEndpoints[service] || "";
        }
        
        // è®¾ç½®APIçŠ¶æ€
        function setApiStatus(status) {
          state.apiStatus = status;
        }
        
        // æ˜¾ç¤ºè¿æ¥çŠ¶æ€æ¶ˆæ¯
        function showConnectionStatus(message, isError = false) {
          const statusMsg = addMessageToChat('assistant', message);
          if (isError) {
            statusMsg.style.color = '#ef4444';
          } else {
            statusMsg.style.color = '#10b981';
          }
        }
        
        
        // ç»‘å®šæ‚¬æµ®çª—ç›¸å…³äº‹ä»¶
        pythonInterfaceBtn.addEventListener('click', openPythonModal);
        modalCloseBtn.addEventListener('click', closePythonModal);
        modalMinimizeBtn.addEventListener('click', toggleMinimize);
        
        // èŠå¤©ç›¸å…³äº‹ä»¶
        const sendBtn = document.getElementById('send-btn');
        const voiceBtn = document.getElementById('voice-btn');
        const fileUploadBtn = document.getElementById('file-upload-btn');
        const fileInput = document.getElementById('file-input');
        const stopRecordingBtn = document.getElementById('stop-recording');
        const clearFilesBtn = document.getElementById('clear-files');
        
        sendBtn.addEventListener('click', sendMessage);
        chatInput.addEventListener('keydown', handleChatInput);
        
        // è¯­éŸ³å½•åˆ¶äº‹ä»¶
        voiceBtn.addEventListener('click', () => {
          if (isRecording) {
            stopVoiceRecording();
          } else {
            startVoiceRecording();
          }
        });
        
        stopRecordingBtn.addEventListener('click', stopVoiceRecording);
        
        // æ–‡ä»¶ä¸Šä¼ äº‹ä»¶
        fileUploadBtn.addEventListener('click', () => {
          fileInput.click();
        });
        
        fileInput.addEventListener('change', handleFileSelect);
        clearFilesBtn.addEventListener('click', clearSelectedFiles);
        
        // ä¿®å¤è¾“å…¥æ³•å…¼å®¹æ€§é—®é¢˜
        chatInput.addEventListener('compositionstart', () => {
          chatInput.isComposing = true;
        });
        chatInput.addEventListener('compositionend', () => {
          chatInput.isComposing = false;
        });
        
        // è‡ªåŠ¨è°ƒæ•´è¾“å…¥æ¡†é«˜åº¦
        chatInput.addEventListener('input', () => {
          chatInput.style.height = 'auto';
          chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
        });
        
        // é«˜çº§è®¾ç½®äº‹ä»¶
        testApiBtn.addEventListener('click', testApiConnection);
        apiServiceSelect.addEventListener('change', updateApiUI);
        
        // åˆå§‹åŒ–æ‹–æ‹½å’Œç¼©æ”¾åŠŸèƒ½
        initModalDrag();
        initModalResize();
        
        // åˆå§‹åŒ–APIç«¯ç‚¹é…ç½®
        apiEndpointInput.value = state.apiEndpoints.chat;
        
        // --- æœ¬åœ°æ¨¡å¼ï¼šå·¥å…·å‡½æ•°ä¸æ•°æ®æµ ---
        function dataURLFromBlankPNG(width, height, fillColor = "#ffffff") {
          const c = document.createElement("canvas");
          c.width = width; c.height = height;
          const ctx = c.getContext("2d");
          // ç™½æ¿èƒŒæ™¯
          ctx.fillStyle = fillColor;
          ctx.fillRect(0, 0, width, height);
          return c.toDataURL("image/png");
        }

        // --- ç”»å¸ƒå°ºå¯¸è®¡ç®—å‡½æ•° ---
        function calculateCanvasSize(originalWidth, originalHeight) {
          // iPadå†…å­˜é™åˆ¶å‚æ•°
          const MAX_CANVAS_SIZE = 16777216; // 16MBåƒç´ é™åˆ¶
          const MAX_DIMENSION = 9000; // å•è¾¹æœ€å¤§å°ºå¯¸
          
          let canvasWidth = originalWidth;
          let canvasHeight = originalHeight;
          let scale = 1;
          
          // æ£€æŸ¥æ˜¯å¦è¶…è¿‡å•è¾¹é™åˆ¶
          if (canvasWidth > MAX_DIMENSION || canvasHeight > MAX_DIMENSION) {
            const scaleX = MAX_DIMENSION / canvasWidth;
            const scaleY = MAX_DIMENSION / canvasHeight;
            scale = Math.min(scaleX, scaleY);
            canvasWidth = Math.floor(canvasWidth * scale);
            canvasHeight = Math.floor(canvasHeight * scale);
          }
          
          // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æ€»åƒç´ é™åˆ¶
          if (canvasWidth * canvasHeight > MAX_CANVAS_SIZE) {
            const totalPixels = canvasWidth * canvasHeight;
            const pixelScale = Math.sqrt(MAX_CANVAS_SIZE / totalPixels);
            scale = scale * pixelScale;
            canvasWidth = Math.floor(originalWidth * scale);
            canvasHeight = Math.floor(originalHeight * scale);
          }
          
          // ç¡®ä¿æœ€å°å°ºå¯¸
          const MIN_SIZE = 100;
          if (canvasWidth < MIN_SIZE || canvasHeight < MIN_SIZE) {
            const minScale = Math.max(MIN_SIZE / originalWidth, MIN_SIZE / originalHeight);
            scale = Math.max(scale, minScale);
            canvasWidth = Math.floor(originalWidth * scale);
            canvasHeight = Math.floor(originalHeight * scale);
          }
          
          console.log(`ç”»å¸ƒå°ºå¯¸è°ƒæ•´: åŸå§‹(${originalWidth}x${originalHeight}) -> ç”»å¸ƒ(${canvasWidth}x${canvasHeight}), ç¼©æ”¾æ¯”ä¾‹: ${scale.toFixed(3)}`);
          
          return {
            width: canvasWidth,
            height: canvasHeight,
            scale: scale
          };
        }

        // å¤„ç†æœ¬åœ°æ–‡ä»¶åˆ—è¡¨ï¼ˆFileList æˆ– Array<File>ï¼‰
        function handleLocalFiles(fileList) {
          const filesArray = Array.from(fileList).filter(f => f.type.startsWith("image/"));
          if (filesArray.length === 0) return;
          const readers = filesArray.map(file => {
            return new Promise((resolve) => {
              const reader = new FileReader();
              reader.onload = () => resolve({ name: file.name, dataURL: reader.result });
              reader.readAsDataURL(file);
            });
          });
          Promise.all(readers).then(images => {
            images.forEach(img => state.localFiles.push({ name: img.name, dataURL: img.dataURL }));
            renderFileTree();
            sourceInfo.textContent = `æ•°æ®æº: æœ¬åœ° (${state.localFiles.length} å¼ )`;
            statusText.textContent = "å·²å¯¼å…¥å›¾åƒ";
            if (state.activeLocalIndex === null && state.localFiles.length > 0) {
              selectLocalFile(0);
            }
          });
        }

        // ä» dataURL åŠ è½½ä¸ºåº•å›¾ï¼Œè®¾ç½®ç”»å¸ƒå°ºå¯¸ä¸ç¼©æ”¾
        function loadBaseFromDataURL(name, dataURL) {
          const img = new Image();
          img.onload = () => {
            state.originalImageSize = { width: img.width, height: img.height };
            state.imageSize = { width: img.width, height: img.height };
            state.canvasScale = 1;
            state.originalBaseImageDataURL = dataURL;

            // è®¾ç½®ç”»å¸ƒå°ºå¯¸ä¸ºå®¹å™¨å¤§å°
            const containerWidth = canvasContainer.clientWidth;
            const containerHeight = canvasContainer.clientHeight;
            
            baseCanvas.width = drawingCanvas.width = maskCanvas.width = containerWidth;
            baseCanvas.height = drawingCanvas.height = maskCanvas.height = containerHeight;
            
            baseCtx.clearRect(0, 0, baseCanvas.width, baseCanvas.height);
            drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);

            // è®¡ç®—å›¾åƒåœ¨ç”»å¸ƒä¸­çš„ä½ç½®å’Œå¤§å°
            const containerRatio = containerWidth / containerHeight;
            const imageRatio = img.width / img.height;
            let drawWidth, drawHeight, drawX, drawY;
            
            if (containerRatio > imageRatio) {
              drawHeight = containerHeight * 0.9;
              drawWidth = drawHeight * imageRatio;
              drawX = (containerWidth - drawWidth) / 2;
              drawY = (containerHeight - drawHeight) / 2;
            } else {
              drawWidth = containerWidth * 0.9;
              drawHeight = drawWidth / imageRatio;
              drawX = (containerWidth - drawWidth) / 2;
              drawY = (containerHeight - drawHeight) / 2;
            }
            
            // ç»˜åˆ¶å›¾åƒåˆ°åŸºç¡€ç”»å¸ƒ
            baseCtx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
            
            // ä¿å­˜å›¾åƒç»˜åˆ¶ä¿¡æ¯ç”¨äºåæ ‡è½¬æ¢
            state.imageDrawInfo = { x: drawX, y: drawY, width: drawWidth, height: drawHeight };

            // å°è¯•æ¢å¤å¯¹åº”çš„ overlay æ•°æ®
            for (const file of state.localFiles) {
              if (file.name === name && file.overlayData) {
                const overlayImg = new Image();
                overlayImg.onload = () => {
                  drawingCtx.drawImage(overlayImg, drawX, drawY, drawWidth, drawHeight);
                  state.isCanvasReady = true;
                  resetZoomAndPan();
                  statusText.textContent = `å·²åŠ è½½: ${name}`;
                };
                overlayImg.onerror = () => {
                  state.isCanvasReady = true;
                  resetZoomAndPan();
                  statusText.textContent = `å·²åŠ è½½: ${name}`;
                };
                overlayImg.src = file.overlayData;
                return;
              }
            }
            state.isCanvasReady = true;
            resetZoomAndPan();
            statusText.textContent = `å·²åŠ è½½: ${name}`;
          };
          img.onerror = () => {
            showModal(`å›¾åƒåŠ è½½å¤±è´¥: ${name}`);
            statusText.textContent = "å›¾åƒåŠ è½½å¤±è´¥";
          };
          img.src = dataURL;
        }

        // é€‰æ‹©æŸä¸ªæœ¬åœ°å›¾åƒ
        function selectLocalFile(index) {
          // åˆ‡æ¢å‰ä¿å­˜å½“å‰ overlay åˆ°æ—§æ–‡ä»¶æ¡ç›®
          if (state.activeLocalIndex !== null) {
            const prev = state.localFiles[state.activeLocalIndex];
            if (prev) {
              prev.overlayData = drawingCanvas.toDataURL("image/png");
              prev.maskData = maskCanvas.toDataURL("image/png");
            }
          }
          state.activeLocalIndex = index;
          const file = state.localFiles[index];
          if (!file) return;
          // é«˜äº®
          document.querySelectorAll(".file-item.active").forEach(el => el.classList.remove("active"));
          const currentFileEl = Array.from(document.querySelectorAll('.file-item')).find(el => el.textContent.trim().endsWith(file.name));
          if (currentFileEl) currentFileEl.classList.add("active");
          loadBaseFromDataURL(file.name, file.dataURL);
          
          // æ¢å¤è’™ç‰ˆæ•°æ®
          if (file.maskData) {
            const maskImg = new Image();
            maskImg.onload = () => {
              maskCtx.drawImage(maskImg, 0, 0, maskCanvas.width, maskCanvas.height);
            };
            maskImg.src = file.maskData;
          }
        }

        // åˆ›å»ºç™½æ¿
        function setWhiteboard(width = 1920, height = 1080) {
          state.originalImageSize = { width, height };
          state.imageSize = { width, height };
          state.canvasScale = 1;
          state.originalBaseImageDataURL = dataURLFromBlankPNG(width, height, "#ffffff");

          // è®¾ç½®ç”»å¸ƒå°ºå¯¸ä¸ºå®¹å™¨å¤§å°
          const containerWidth = canvasContainer.clientWidth;
          const containerHeight = canvasContainer.clientHeight;
          
          baseCanvas.width = drawingCanvas.width = maskCanvas.width = containerWidth;
          baseCanvas.height = drawingCanvas.height = maskCanvas.height = containerHeight;
          
          // ç™½è‰²åº•æ¿å¡«å……æ•´ä¸ªç”»å¸ƒ
          baseCtx.fillStyle = "#ffffff";
          baseCtx.fillRect(0, 0, baseCanvas.width, baseCanvas.height);
          drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
          maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);

          // è®¾ç½®ç»˜åˆ¶åŒºåŸŸä¿¡æ¯
          state.imageDrawInfo = { x: 0, y: 0, width: containerWidth, height: containerHeight };

          state.isCanvasReady = true;
          resetZoomAndPan();
          statusText.textContent = `ç™½æ¿å·²åˆ›å»º (${containerWidth}x${containerHeight})`;
          sourceInfo.textContent = "æ•°æ®æº: æœ¬åœ° (ç™½æ¿)";
        }

        // --- UI æ›´æ–°å‡½æ•° ---
        function populateWrinkleTypeSelect(wrinkleTypes) {
          wrinkleTypeSelect.innerHTML = '<option value="">è¯·é€‰æ‹©çš±çº¹ç±»å‹</option>';
          wrinkleTypes.forEach((type) => {
            const option = document.createElement("option");
            option.value = type.value;
            option.textContent = type.name;
            wrinkleTypeSelect.appendChild(option);
          });
        }

        function renderFileTree() {
          if (!state.localFiles || state.localFiles.length === 0) {
            fileTreeContainer.innerHTML = '<p class="text-gray-400">æœ¬åœ°æ¨¡å¼ï¼šä½¿ç”¨ä¸Šæ–¹"å¯¼å…¥å›¾åƒ"æŒ‰é’®æˆ–å°†å›¾ç‰‡æ‹–æ‹½åˆ°ç”»å¸ƒåŒºåŸŸã€‚</p>';
            return;
          }
          const html = state.localFiles.map((file, idx) => `
            <div class="file-item ${idx === state.activeLocalIndex ? 'active' : ''}" data-idx="${idx}">
              <i class="fas fa-image mr-2"></i>${file.name}
            </div>`).join("");
          fileTreeContainer.innerHTML = html;
          fileTreeContainer.querySelectorAll('.file-item').forEach(el => {
            el.addEventListener('click', (e) => {
              const idx = parseInt(e.currentTarget.dataset.idx);
              selectLocalFile(idx);
            });
          });
        }

        // å…¼å®¹æ—§é€»è¾‘çš„å ä½ï¼šä¸å†ä½¿ç”¨è¿œç¨‹æ–‡ä»¶é€‰æ‹©
        function selectFile() {}

        // æœ¬åœ°æ¨¡å¼ï¼šéšè—çš±çº¹ç±»å‹é€‰æ‹©å™¨
        if (wrinkleTypeSelect) {
          const wrapper = wrinkleTypeSelect.closest('.flex.flex-col.space-y-2');
          if (wrapper) wrapper.style.display = 'none';
        }

        // --- è’™ç‰ˆç›¸å…³å‡½æ•° ---
        function toggleMask() {
          state.isMaskVisible = !state.isMaskVisible;
          maskCanvas.style.display = state.isMaskVisible ? 'block' : 'none';
          toggleMaskBtn.classList.toggle('active', state.isMaskVisible);
          statusText.textContent = `è’™ç‰ˆå·²${state.isMaskVisible ? 'æ˜¾ç¤º' : 'éšè—'}`;
        }

        function clearMask() {
          maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
          statusText.textContent = "è’™ç‰ˆå·²æ¸…é™¤";
        }

        function updateMaskColor(e) {
          const hex = e.target.value;
          const r = parseInt(hex.slice(1, 3), 16);
          const g = parseInt(hex.slice(3, 5), 16);
          const b = parseInt(hex.slice(5, 7), 16);
          state.maskColor = `rgba(${r}, ${g}, ${b}, ${state.maskOpacity/100})`;
        }

        function updateMaskOpacity(e) {
          state.maskOpacity = parseInt(e.target.value);
          maskOpacityValueDisplay.textContent = `${state.maskOpacity}%`;
          maskCanvas.style.opacity = state.maskOpacity / 100;
          
          // æ›´æ–°é¢œè‰²ä»¥åŒ…å«æ–°çš„é€æ˜åº¦
          const hex = maskColorInput.value;
          const r = parseInt(hex.slice(1, 3), 16);
          const g = parseInt(hex.slice(3, 5), 16);
          const b = parseInt(hex.slice(5, 7), 16);
          state.maskColor = `rgba(${r}, ${g}, ${b}, ${state.maskOpacity/100})`;
        }

        // --- å¤šè¾¹å½¢å·¥å…·å‡½æ•° ---
        function redrawPolygonPreview(mousePos) {
            if (!state.savedCanvasState) return;
            drawingCtx.putImageData(state.savedCanvasState, 0, 0);
            if (state.polygonPoints.length === 0) return;
            
            drawingCtx.beginPath();
            drawingCtx.moveTo(state.polygonPoints[0].x, state.polygonPoints[0].y);
            for (let i = 1; i < state.polygonPoints.length; i++) {
                drawingCtx.lineTo(state.polygonPoints[i].x, state.polygonPoints[i].y);
            }
            if (mousePos) {
                drawingCtx.lineTo(mousePos.x, mousePos.y);
            }
            drawingCtx.stroke();
        }

        function finishPolygon(shouldClosePath = true) {
            if (!state.isDrawingPolygon || state.polygonPoints.length < 2) {
                cancelPolygon();
                return;
            }
            drawingCtx.putImageData(state.savedCanvasState, 0, 0);
            drawingCtx.beginPath();
            drawingCtx.moveTo(state.polygonPoints[0].x, state.polygonPoints[0].y);
            for (let i = 1; i < state.polygonPoints.length; i++) {
                drawingCtx.lineTo(state.polygonPoints[i].x, state.polygonPoints[i].y);
            }
            if (shouldClosePath) {
                drawingCtx.closePath();
            }
            drawingCtx.stroke();
            state.polygonPoints = [];
            state.isDrawingPolygon = false;
            state.savedCanvasState = null;
        }

        function cancelPolygon() {
            if (state.isDrawingPolygon) {
                drawingCtx.putImageData(state.savedCanvasState, 0, 0);
                state.polygonPoints = [];
                state.isDrawingPolygon = false;
                state.savedCanvasState = null;
            }
        }

        // --- ç”»å¸ƒä¸å·¥å…· ---
        function updateTool(newTool) {
          if (state.isDrawingPolygon) finishPolygon(false); // å¦‚æœåˆ‡æ¢å·¥å…·ï¼Œåˆ™å®Œæˆå½“å‰çš„å¤šè¾¹å½¢ï¼ˆä¸é—­åˆï¼‰
          state.currentTool = newTool;
          [toolPan, toolPencil, toolEraser, toolRectangle, toolPolygon, toolMask].forEach((btn) =>
            btn.classList.remove("active")
          );
          document.getElementById(`tool-${newTool}`).classList.add("active");
          
          // åˆ‡æ¢è’™ç‰ˆæ¨¡å¼è§†è§‰æ•ˆæœ
          if (newTool === "mask") {
            document.body.classList.add("mask-mode");
          } else {
            document.body.classList.remove("mask-mode");
          }
          
          if (newTool === "pan") canvasContainer.style.cursor = "grab";
          else if (newTool === "eraser" || newTool === "pencil" || newTool === "mask") canvasContainer.style.cursor = "none";
          else canvasContainer.style.cursor = "crosshair";
          
          const colorContainer = document.getElementById("color-container");
          const maskColorContainer = document.getElementById("mask-color-container");
          if (newTool === "pencil" || newTool === "rectangle" || newTool === "polygon") {
            colorContainer.style.opacity = "1";
            brushColorInput.disabled = false;
            maskColorContainer.style.opacity = "0.5";
            maskColorInput.disabled = true;
          } else if (newTool === "mask") {
            colorContainer.style.opacity = "0.5";
            brushColorInput.disabled = true;
            maskColorContainer.style.opacity = "1";
            maskColorInput.disabled = false;
          } else {
            colorContainer.style.opacity = "0.5";
            brushColorInput.disabled = true;
            maskColorContainer.style.opacity = "0.5";
            maskColorInput.disabled = true;
          }
          
          if (newTool !== "eraser") eraserPreview.style.display = "none";
          if (newTool !== "pencil" && newTool !== "mask") brushPreview.style.display = "none";
        }

        toolPan.addEventListener("click", () => updateTool("pan"));
        toolPencil.addEventListener("click", () => updateTool("pencil"));
        toolRectangle.addEventListener("click", () => updateTool("rectangle"));
        toolPolygon.addEventListener("click", () => updateTool("polygon"));
        toolEraser.addEventListener("click", () => updateTool("eraser"));
        toolMask.addEventListener("click", () => updateTool("mask"));

        layerOpacityInput.addEventListener("input", (e) => {
          const opacityPercent = parseInt(e.target.value);
          layerOpacityValueDisplay.textContent = `${opacityPercent}%`;
          drawingCanvas.style.opacity = opacityPercent / 100;
        });

        maskOpacityInput.addEventListener("input", updateMaskOpacity);
        maskColorInput.addEventListener("input", updateMaskColor);

        function updateToolPreview(e) {
          const containerRect = canvasContainer.getBoundingClientRect();
          const size = parseInt(brushSizeInput.value);
          
          const previewX = e.clientX - containerRect.left - size / 2;
          const previewY = e.clientY - containerRect.top - size / 2;
          
          if (state.currentTool === "eraser") {
            eraserPreview.style.display = "block";
            eraserPreview.style.width = `${size}px`;
            eraserPreview.style.height = `${size}px`;
            eraserPreview.style.left = `${previewX}px`;
            eraserPreview.style.top = `${previewY}px`;
            brushPreview.style.display = "none";
          } else if (state.currentTool === "pencil" || state.currentTool === "mask") {
            brushPreview.style.display = "block";
            brushPreview.style.width = `${size}px`;
            brushPreview.style.height = `${size}px`;
            brushPreview.style.left = `${previewX}px`;
            brushPreview.style.top = `${previewY}px`;
            eraserPreview.style.display = "none";
            
            // è®¾ç½®é¢„è§ˆé¢œè‰²
            if (state.currentTool === "mask") {
              brushPreview.style.borderColor = maskColorInput.value;
              brushPreview.style.backgroundColor = maskColorInput.value.replace(')', ', 0.1)');
            } else {
              brushPreview.style.borderColor = "#22c55e";
              brushPreview.style.backgroundColor = "rgba(34, 197, 94, 0.1)";
            }
          } else {
            eraserPreview.style.display = "none";
            brushPreview.style.display = "none";
          }
        }

        canvasContainer.addEventListener("pointermove", updateToolPreview);
        canvasContainer.addEventListener("pointerenter", updateToolPreview);
        canvasContainer.addEventListener("pointerleave", () => {
          eraserPreview.style.display = "none";
          brushPreview.style.display = "none";
        });

        function getCanvasCoordinates(e) {
          const rect = canvasContainer.getBoundingClientRect();
          const rawX = e.clientX - rect.left;
          const rawY = e.clientY - rect.top;
          
          // è€ƒè™‘ç”»å¸ƒçš„ç¼©æ”¾å’Œå¹³ç§»å˜æ¢
          const x = (rawX - state.pan.x) / state.zoom;
          const y = (rawY - state.pan.y) / state.zoom;
          
          return { x, y };
        }

        function draw(e) {
          if (!state.isDrawing) return;
          const pos = getCanvasCoordinates(e);
          
          // å‹åŠ›æ„Ÿåº”æ”¯æŒ
          const pressure = e.pressure > 0 ? e.pressure : 0.5;
          const baseBrushSize = parseFloat(brushSizeInput.value);
          const adjustedBrushSize = baseBrushSize * (0.5 + pressure * 0.5);
          
          const currentCtx = state.currentTool === "mask" ? maskCtx : drawingCtx;
          
          if (state.currentTool === "eraser") {
            currentCtx.globalCompositeOperation = "destination-out";
          } else {
            currentCtx.globalCompositeOperation = "source-over";
          }
          
          currentCtx.lineWidth = adjustedBrushSize;
          currentCtx.lineCap = "round";
          currentCtx.lineJoin = "round";
          
          if (state.currentTool === "mask") {
            currentCtx.strokeStyle = maskColorInput.value;
          } else if (state.currentTool === "pencil") {
            currentCtx.strokeStyle = brushColorInput.value;
          }
          
          if (state.lastPos) {
            // åªæœ‰åœ¨è¿ç»­ç»˜åˆ¶æ—¶æ‰è¿çº¿
            currentCtx.beginPath();
            currentCtx.moveTo(state.lastPos.x, state.lastPos.y);
            currentCtx.lineTo(pos.x, pos.y);
            currentCtx.stroke();
          } else {
            // æ–°ç¬”ç”»å¼€å§‹ï¼Œç»˜åˆ¶ä¸€ä¸ªç‚¹
            currentCtx.beginPath();
            currentCtx.arc(pos.x, pos.y, adjustedBrushSize / 2, 0, Math.PI * 2);
            currentCtx.fill();
          }
          
          state.lastPos = pos;
        }

        function pan(e) {
          if (!state.isPanning) return;
          const dx = e.clientX - state.lastX;
          const dy = e.clientY - state.lastY;
          state.pan.x += dx;
          state.pan.y += dy;
          [state.lastX, state.lastY] = [e.clientX, e.clientY];
          updateCanvasTransform();
        }

        drawingCanvas.addEventListener("pointerdown", (e) => {
          if (!state.isCanvasReady) return;
          
          // æ£€æµ‹å‹åŠ›æ„Ÿåº”æ”¯æŒ
          if (e.pressure > 0 && e.pressure < 1) {
            if (!state.supportsPressure) {
              state.supportsPressure = true;
              console.log("æ£€æµ‹åˆ°å‹åŠ›æ„Ÿåº”æ”¯æŒ");
            }
          }
          
          // è®¾ç½®æŒ‡é’ˆæ•è·ä»¥ç¡®ä¿åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šæ­£å¸¸å·¥ä½œ
          drawingCanvas.setPointerCapture(e.pointerId);

          if (state.currentTool === "pan") {
            state.isPanning = true;
            [state.lastX, state.lastY] = [e.clientX, e.clientY];
            canvasContainer.style.cursor = "grabbing";
          } else if (state.currentTool === 'polygon') {
            const pos = getCanvasCoordinates(e);
            if (state.isDrawingPolygon && state.polygonPoints.length > 1) {
                const firstPoint = state.polygonPoints[0];
                const dx = pos.x - firstPoint.x;
                const dy = pos.y - firstPoint.y;
                const threshold = 10 / state.zoom;
                if (Math.sqrt(dx * dx + dy * dy) < threshold) {
                    finishPolygon(true);
                    return;
                }
            }
            if (!state.isDrawingPolygon) {
                state.isDrawingPolygon = true;
                state.savedCanvasState = drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height);
                drawingCtx.lineWidth = brushSizeInput.value;
                drawingCtx.strokeStyle = brushColorInput.value;
                drawingCtx.lineJoin = "round";
                drawingCtx.lineCap = "round";
            }
            state.polygonPoints.push(pos);
            redrawPolygonPreview();
          } else if (state.currentTool === 'mask') {
            state.isDrawing = true;
            const pos = getCanvasCoordinates(e);
            state.lastPos = pos;
            maskCtx.globalCompositeOperation = "source-over";
            maskCtx.globalAlpha = state.maskOpacity / 100;
            maskCtx.strokeStyle = maskColorInput.value;
            maskCtx.lineWidth = brushSizeInput.value;
            maskCtx.lineJoin = "round";
            maskCtx.lineCap = "round";
            maskCtx.beginPath();
            maskCtx.moveTo(pos.x, pos.y);
          } else {
            state.isDrawing = true;
            const pos = getCanvasCoordinates(e);
            state.lastPos = pos;
            drawingCtx.globalCompositeOperation = "source-over";
            drawingCtx.globalAlpha = 1.0;
            if (state.currentTool === 'rectangle') {
                state.savedCanvasState = drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height);
                drawingCtx.lineWidth = brushSizeInput.value;
                drawingCtx.lineJoin = "miter";
                drawingCtx.lineCap = "square";
                drawingCtx.strokeStyle = brushColorInput.value;
            } else {
                // å‹åŠ›æ„Ÿåº”åˆå§‹è®¾ç½®
                const pressure = e.pressure > 0 ? e.pressure : 0.5;
                const baseBrushSize = parseFloat(brushSizeInput.value);
                const adjustedBrushSize = baseBrushSize * (0.5 + pressure * 0.5);
                
                drawingCtx.lineWidth = adjustedBrushSize;
                drawingCtx.lineJoin = "round";
                drawingCtx.lineCap = "round";
                if (state.currentTool === "eraser") {
                  drawingCtx.globalCompositeOperation = "destination-out";
                  drawingCtx.globalAlpha = 1.0;
                  drawingCtx.strokeStyle = `rgba(0, 0, 0, 1)`;
                } else if (state.currentTool === "pencil") {
                  const color = brushColorInput.value;
                  const r = parseInt(color.slice(1, 3), 16);
                  const g = parseInt(color.slice(3, 5), 16);
                  const b = parseInt(color.slice(5, 7), 16);
                  drawingCtx.strokeStyle = `rgba(${r}, ${g}, ${b}, 1.0)`;
                }
                state.lastPos = null; // ç¡®ä¿æ–°ç¬”ç”»å¼€å§‹æ—¶æ¸…é™¤ä¸Šä¸€ä¸ªä½ç½®
                draw(e);
            }
          }
        });

        drawingCanvas.addEventListener("pointermove", (e) => {
          if (state.isDrawing) {
            if (state.currentTool === 'rectangle') {
                if (state.savedCanvasState) drawingCtx.putImageData(state.savedCanvasState, 0, 0);
                const pos = getCanvasCoordinates(e);
                const width = pos.x - state.lastPos.x;
                const height = pos.y - state.lastPos.y;
                drawingCtx.beginPath();
                drawingCtx.rect(state.lastPos.x, state.lastPos.y, width, height);
                drawingCtx.stroke();
            } else {
                draw(e);
            }
          } else if (state.isPanning) {
            pan(e);
          } else if (state.currentTool === 'polygon' && state.isDrawingPolygon) {
            redrawPolygonPreview(getCanvasCoordinates(e));
          }
        });

        drawingCanvas.addEventListener("pointerup", (e) => {
            if (state.isDrawing && state.currentTool !== 'polygon') {
                if (state.currentTool === 'rectangle') state.savedCanvasState = null;
                state.isDrawing = false;
                state.lastPos = null; // æ¸…é™¤æœ€åä½ç½®ï¼Œé˜²æ­¢è‡ªåŠ¨è¿çº¿
            }
            if (state.isPanning) {
                state.isPanning = false;
                canvasContainer.style.cursor = "grab";
            }
            
            // é‡Šæ”¾æŒ‡é’ˆæ•è·
            drawingCanvas.releasePointerCapture(e.pointerId);
        });

        drawingCanvas.addEventListener("pointerleave", () => {
            if (state.isDrawing && state.currentTool !== 'polygon') {
                state.isDrawing = false;
                state.lastPos = null; // æ¸…é™¤æœ€åä½ç½®ï¼Œé˜²æ­¢è‡ªåŠ¨è¿çº¿
            }
        });

        // --- ç¼©æ”¾ä¸å¹³ç§» ---
        function updateCanvasTransform() {
          const transform = `translate(${state.pan.x}px, ${state.pan.y}px) scale(${state.zoom})`;
          baseCanvas.style.transform = transform;
          drawingCanvas.style.transform = transform;
          maskCanvas.style.transform = transform;
          zoomLevelDisplay.textContent = `${Math.round(state.zoom * 100)}%`;
        }

        function adjustZoom(delta) {
          if (!state.isCanvasReady) return;
          const newZoom = Math.max(0.1, Math.min(10, state.zoom + delta));
          state.zoom = newZoom;
          updateCanvasTransform();
        }

        zoomInBtn.addEventListener("click", () => adjustZoom(0.1));
        zoomOutBtn.addEventListener("click", () => adjustZoom(-0.1));
        zoomResetBtn.addEventListener("click", resetZoomAndPan);

        canvasContainer.addEventListener("wheel", (e) => {
          e.preventDefault();
          const delta = e.deltaY > 0 ? -0.1 : 0.1;
          adjustZoom(delta);
        });

        function resetZoomAndPan() {
          state.zoom = 1;
          state.pan.x = 0;
          state.pan.y = 0;
          updateCanvasTransform();
        }

        function downloadURI(uri, name) {
          const link = document.createElement("a");
          link.download = name;
          link.href = uri;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }

        // è¿œç¨‹åˆ·æ–°ä¸å†éœ€è¦
        async function refreshFileListAndReselect() { renderFileTree(); }

        // å¯¼å‡ºä»…æ ‡æ³¨å›¾å±‚ PNG
        saveBtn.addEventListener("click", async () => {
          if (!state.isCanvasReady) {
            showModal("å½“å‰æ²¡æœ‰å¯å¯¼å‡ºçš„æ ‡æ³¨å›¾å±‚ã€‚");
            return;
          }
          try {
            let finalCanvas = drawingCanvas;
            if (state.canvasScale !== 1) {
              const tempCanvas = document.createElement("canvas");
              tempCanvas.width = state.originalImageSize.width;
              tempCanvas.height = state.originalImageSize.height;
              const tempCtx = tempCanvas.getContext("2d");
              tempCtx.drawImage(drawingCanvas, 0, 0, state.originalImageSize.width, state.originalImageSize.height);
              finalCanvas = tempCanvas;
            }
            const canvasDataURL = finalCanvas.toDataURL("image/png");
            const name = state.activeLocalIndex !== null ? state.localFiles[state.activeLocalIndex].name : 'whiteboard.png';
            const baseName = name.split('.').slice(0, -1).join('.') || 'whiteboard';
            downloadURI(canvasDataURL, `${baseName}_overlay.png`);
          } catch (error) {
            console.error("å¯¼å‡ºæ ‡æ³¨å¤±è´¥:", error);
            showModal(`å¯¼å‡ºæ ‡æ³¨å¤±è´¥: ${error.message}`);
          }
        });

        exportBtn.addEventListener("click", () => {
          if (!state.isCanvasReady) {
            showModal("æ²¡æœ‰æ´»åŠ¨çš„å›¾åƒå¯å¯¼å‡ºã€‚");
            return;
          }
          const exportCanvas = document.createElement("canvas");
          exportCanvas.width = state.originalImageSize.width;
          exportCanvas.height = state.originalImageSize.height;
          const exportCtx = exportCanvas.getContext("2d");
          const baseImg = new Image();
          baseImg.onload = () => {
            exportCtx.drawImage(baseImg, 0, 0);
            if (state.canvasScale !== 1) {
              exportCtx.drawImage(drawingCanvas, 0, 0, state.originalImageSize.width, state.originalImageSize.height);
            } else {
              exportCtx.drawImage(drawingCanvas, 0, 0);
            }
            
            // æ·»åŠ è’™ç‰ˆå›¾å±‚
            if (state.isMaskVisible) {
              exportCtx.globalAlpha = state.maskOpacity / 100;
              if (state.canvasScale !== 1) {
                exportCtx.drawImage(maskCanvas, 0, 0, state.originalImageSize.width, state.originalImageSize.height);
              } else {
                exportCtx.drawImage(maskCanvas, 0, 0);
              }
            }
            
            const name = state.activeLocalIndex !== null ? state.localFiles[state.activeLocalIndex].name : 'whiteboard.png';
            const baseName = name.split('.').slice(0, -1).join('.') || 'whiteboard';
            downloadURI(exportCanvas.toDataURL("image/png"), `${baseName}_merged.png`);
          };
          baseImg.onerror = () => {
            // é€€åŒ–ä¸ºç›´æ¥ç”¨å½“å‰å¯è§åº•å›¾
            const fallback = new Image();
            fallback.onload = () => {
              exportCtx.drawImage(fallback, 0, 0, state.originalImageSize.width, state.originalImageSize.height);
              if (state.canvasScale !== 1) {
                exportCtx.drawImage(drawingCanvas, 0, 0, state.originalImageSize.width, state.originalImageSize.height);
              } else {
                exportCtx.drawImage(drawingCanvas, 0, 0);
              }
              
              // æ·»åŠ è’™ç‰ˆå›¾å±‚
              if (state.isMaskVisible) {
                exportCtx.globalAlpha = state.maskOpacity / 100;
                if (state.canvasScale !== 1) {
                  exportCtx.drawImage(maskCanvas, 0, 0, state.originalImageSize.width, state.originalImageSize.height);
                } else {
                  exportCtx.drawImage(maskCanvas, 0, 0);
                }
              }
              
              const name = state.activeLocalIndex !== null ? state.localFiles[state.activeLocalIndex].name : 'whiteboard.png';
              const baseName = name.split('.').slice(0, -1).join('.') || 'whiteboard';
              downloadURI(exportCanvas.toDataURL("image/png"), `${baseName}_merged.png`);
            };
            fallback.src = baseCanvas.toDataURL();
          };
          baseImg.src = state.originalBaseImageDataURL || baseCanvas.toDataURL();
        });

        // å¯¼å…¥å›¾åƒ
        importBtn.addEventListener('click', () => localImageInput.click());
        localImageInput.addEventListener('change', (e) => {
          if (e.target.files && e.target.files.length > 0) {
            handleLocalFiles(e.target.files);
            e.target.value = '';
          }
        });

        // æ”¯æŒæ‹–æ‹½å¯¼å…¥
        canvasContainer.addEventListener('dragover', (e) => {
          e.preventDefault();
        });
        canvasContainer.addEventListener('drop', (e) => {
          e.preventDefault();
          if (e.dataTransfer && e.dataTransfer.files) {
            handleLocalFiles(e.dataTransfer.files);
          }
        });

        // è’™ç‰ˆæ§åˆ¶
        toggleMaskBtn.addEventListener('click', toggleMask);
        clearMaskBtn.addEventListener('click', clearMask);

        // --- é”®ç›˜å¿«æ·é”® ---
        window.addEventListener("keydown", (e) => {
          if (e.target.tagName === 'INPUT') return; // Ignore keydown on input elements
          switch (e.key.toLowerCase()) {
            case "b": updateTool("pencil"); break;
            case "e": updateTool("eraser"); break;
            case "v": updateTool("pan"); break;
            case "r": updateTool("rectangle"); break;
            case "p": updateTool("polygon"); break;
            case "t": updateTool("mask"); break;
            case "m": 
              e.preventDefault();
              toggleMask();
              break;
            case "enter":
              if (state.currentTool === 'polygon') {
                e.preventDefault();
                finishPolygon(true);
              }
              break;
            case "escape":
               if (state.currentTool === 'polygon') {
                e.preventDefault();
                cancelPolygon();
              }
              break;
            case "+":
            case "=":
              e.preventDefault();
              adjustZoom(0.1);
              break;
            case "-":
              e.preventDefault();
              adjustZoom(-0.1);
              break;
          }
        });

        // --- æ±‰å ¡èœå•æ§åˆ¶ ---
        hamburgerMenu.addEventListener("click", () => {
          sidebar.classList.toggle("show");
        });
        
        // ç‚¹å‡»ä¾§è¾¹æ å¤–éƒ¨åŒºåŸŸå…³é—­ä¾§è¾¹æ 
        document.addEventListener("click", (e) => {
          if (window.innerWidth <= 2290 && 
              !sidebar.contains(e.target) && 
              !hamburgerMenu.contains(e.target) && 
              sidebar.classList.contains("show")) {
            sidebar.classList.remove("show");
          }
        });

        // --- æ¨¡æ€æ¡† ---
        function showModal(message) {
          modalMessage.textContent = message;
          modal.classList.remove("hidden");
        }
        modalClose.addEventListener("click", () =>
          modal.classList.add("hidden")
        );

        window.addEventListener("resize", resetZoomAndPan);

        async function initialize() {
          try {
            statusText.textContent = "æ­£åœ¨åˆå§‹åŒ–æœ¬åœ°æ¨¡å¼...";
            // ç§»åŠ¨ç«¯ä¼˜åŒ–ï¼šé˜²æ­¢åŒå‡»ç¼©æ”¾
            document.addEventListener('touchstart', function(e) {
              if (e.touches.length > 1) {
                e.preventDefault();
              }
            }, { passive: false });

            let lastTouchEnd = 0;
            document.addEventListener('touchend', function(e) {
              const now = (new Date()).getTime();
              if (now - lastTouchEnd <= 300) {
                e.preventDefault();
              }
              lastTouchEnd = now;
            }, { passive: false });

            // é»˜è®¤åˆ›å»ºç™½æ¿
            setWhiteboard(1920, 1080);
            renderFileTree();
            statusText.textContent = "æœ¬åœ°æ¨¡å¼å·²å°±ç»ª";
            sourceInfo.textContent = "æ•°æ®æº: æœ¬åœ°";
            
            // åˆå§‹åŒ–è’™ç‰ˆè®¾ç½®
            maskCanvas.style.display = state.isMaskVisible ? 'block' : 'none';
            toggleMaskBtn.classList.toggle('active', state.isMaskVisible);
            maskCanvas.style.opacity = state.maskOpacity / 100;
          } catch (error) {
            console.error("åˆå§‹åŒ–å¤±è´¥:", error);
            statusText.textContent = "åˆå§‹åŒ–å¤±è´¥";
          }
        }

        initialize();
        updateTool("pencil");
        
        // ä¿®æ”¹å¯¼å…¥å›¾åƒçš„å¤„ç†é€»è¾‘
        importBtn.addEventListener('click', () => localImageInput.click());
        localImageInput.addEventListener('change', (e) => {
          if (e.target.files && e.target.files.length > 0) {
            // ä½¿ç”¨FormDataä¸Šä¼ æ–‡ä»¶åˆ°Flaskåç«¯
            const formData = new FormData();
            for (let i = 0; i < e.target.files.length; i++) {
              formData.append('file', e.target.files[i]);
            }
            
            fetch('/upload', {
              method: 'POST',
              body: formData
            })
            .then(response => response.json())
            .then(data => {
              if (data.error) {
                showModal(`ä¸Šä¼ å¤±è´¥: ${data.error}`);
                return;
              }
              
              // å°†ä¸Šä¼ çš„å›¾åƒæ·»åŠ åˆ°æœ¬åœ°æ–‡ä»¶åˆ—è¡¨
              data.files.forEach(fileInfo => {
                state.localFiles.push({
                  name: fileInfo.name,
                  dataURL: fileInfo.url, // ä½¿ç”¨æœåŠ¡å™¨æä¾›çš„URL
                  serverStored: true // æ ‡è®°ä¸ºæœåŠ¡å™¨å­˜å‚¨çš„æ–‡ä»¶
                });
              });
              
              renderFileTree();
              sourceInfo.textContent = `æ•°æ®æº: æœåŠ¡å™¨ (${state.localFiles.length} å¼ )`;
              statusText.textContent = "å·²å¯¼å…¥å›¾åƒ";
              if (state.activeLocalIndex === null && state.localFiles.length > 0) {
                selectLocalFile(0);
              }
            })
            .catch(error => {
              console.error('ä¸Šä¼ é”™è¯¯:', error);
              showModal('ä¸Šä¼ æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯');
            });
            
            e.target.value = '';
          }
        });

        // ä¿®æ”¹ä¿å­˜æ ‡æ³¨çš„å¤„ç†é€»è¾‘
        saveBtn.addEventListener("click", async () => {
          if (!state.isCanvasReady) {
            showModal("å½“å‰æ²¡æœ‰å¯å¯¼å‡ºçš„æ ‡æ³¨å›¾å±‚ã€‚");
            return;
          }
          try {
            let finalCanvas = drawingCanvas;
            if (state.canvasScale !== 1) {
              const tempCanvas = document.createElement("canvas");
              tempCanvas.width = state.originalImageSize.width;
              tempCanvas.height = state.originalImageSize.height;
              const tempCtx = tempCanvas.getContext("2d");
              tempCtx.drawImage(drawingCanvas, 0, 0, state.originalImageSize.width, state.originalImageSize.height);
              finalCanvas = tempCanvas;
            }
            const canvasDataURL = finalCanvas.toDataURL("image/png");
            const name = state.activeLocalIndex !== null ? state.localFiles[state.activeLocalIndex].name : 'whiteboard.png';
            const baseName = name.split('.').slice(0, -1).join('.') || 'whiteboard';
            
            // å‘é€åˆ°æœåŠ¡å™¨ä¿å­˜
            fetch('/save_annotation', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                image_data: canvasDataURL,
                filename: `${baseName}_overlay.png`
              })
            })
            .then(response => response.json())
            .then(data => {
              if (data.success) {
                showModal(`æ ‡æ³¨å·²ä¿å­˜: ${data.filename}`);
                // å¯é€‰: æä¾›ä¸‹è½½é“¾æ¥
                const downloadLink = document.createElement('a');
                downloadLink.href = data.url;
                downloadLink.download = data.filename;
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
              } else {
                showModal(`ä¿å­˜å¤±è´¥: ${data.error}`);
              }
            })
            .catch(error => {
              console.error('ä¿å­˜é”™è¯¯:', error);
              showModal('ä¿å­˜æ ‡æ³¨æ—¶å‘ç”Ÿé”™è¯¯');
            });
          } catch (error) {
            console.error("å¯¼å‡ºæ ‡æ³¨å¤±è´¥:", error);
            showModal(`å¯¼å‡ºæ ‡æ³¨å¤±è´¥: ${error.message}`);
          }
        });
      });
    </script>
  </body>
</html>